# 徳丸本
- ## 2章 実習環境のセットアップ
- ### 環境構築メモ
	- [virtual box の ホストオンリーアダプターが非推奨だったのでホストオンリーネットワークを使ってみた](https://zenn.dev/yufuworks/scraps/032456e30590cc)
	- [安全なwebアプリケーションの作り方 第2版、「2.実習環境のセットアップ」で出る警告について(OWASP ZAPの設定方法)](https://teratail.com/questions/197984)
- ## 3章 Webセキュリティの基礎
- ### 3.1 HTTPとセッション管理
	- application/x-www-form-urlencoded
		- 名前=値の組を&で繋いだデータ形式
		- 名前と値はパーセントエンコードされている(urlencodedとついているのはそのため)
	- パーセントエンコーディング
		- URL上で特別な意味を持つ記号や日本語などをURL上で記述するために用いる
			- ブラウザで「あ」の検索結果のURLを見ると、クエリパラメータqに設定されている値が「あ」のパーセントエンコーディングになっている
			- しかし、URL上とは限らない気が...(application/x-www-form-urlencodedの場合はリクエストボディで使っているので)
		- バイト単位で%xxの形式で表す
			- 例えば、「あ」はUTF-8で、E3 81 82 になるので、パーセントエンコーディング後は%E3%81%82になる
			- スペースは%20となるが、application/x-www-form-urlencodedの場合は「+」になる
				- 例えば「I'm a programmer」をパーセントエンコーディングすると、I%27m+a+programmerとなる(アポストロフィは%27)
	- Refererヘッダ
		- リンク元のURLを示すヘッダ
		- form要素によるフォーム送信、aタグによるリンク、imgタグによる画像参照などでRefererヘッダがつく
		- Refererを確認することで、アプリケーションが意図した遷移を経ていることが確認出来るが、ローカルプロキシ等で改変可能であるため、正しいリンク元を示しているとは限らない
		- URLがセッションIDなどの秘密情報を含んでいると、Referer経由で外部に漏洩する可能性がある
		- 正しいスペルはReferrerだが、ITの世界ではRefererとなった([参考](https://wa3.i-3-i.info/diff505refer.html))
	- Basic認証
		- Basic認証が必要なページにリクエストがあると、サーバは401と[WWW-Authenticateヘッダ](https://developer.mozilla.org/ja/docs/Web/HTTP/Headers/WWW-Authenticate)を返す
		  id:: 64d5c020-4b28-4183-812d-125ce946edc4
			- WWW-Authenticateヘッダでどのような認証方式が使用できるかや、その認証方式が必要とするデータを示す
			- ```
			  HTTP/1.1 401 Unauthorized
			  WWW-Authenticate: Basic realm="..."
			  ```
		- これを受けたブラウザはユーザにユーザ名とパスワードの入力を求める
		- ユーザによってユーザ名とパスワードが入力されると、ブラウザは、ユーザ名とパスワードを:で区切って、Base64でエンコードし、Authorizationヘッダに付与して送信する
			- ```
			  Authorization: Basic dGVzdC11c2VyOnBhc3N3b3Jk
			  ```
		- 以降はブラウザが自動でAuthorizationヘッダを付与してくれる
	- Cookieとセッション管理
		- セッションIDに求められる要件
			- 第三者がセッションIDを推測できないこと
				- 自作のセッション管理ではなく、フレームワークが提供するセッション管理を使うべき
			- 第三者からセッションIDを強制されないこと
				- 強制できると、セッションIDの固定化攻撃に繋がる
			- 第三者にセッションIDが漏洩しないこと
				- 漏洩する原因は、Cookieの属性の不備、XSS、Refererヘッダ(セッションIDをURLに保持している場合)など
		- Cookieの属性
			- Domain属性
				- Cookieを送信するサーバのドメインを設定する
				- Domain属性が設定されていない場合、Cookieをセットしたサーバにのみ送信される(a.example.jpがセットしたCookieはb.example.jpには送信されない)
				- Domain属性を設定すると、そのドメインとサブドメインに送信される(Domain属性がexample.jpならa.example.jpがセットしたCookieはb.example.jpにも送信される)
				- Domain属性は原則として設定しないのが安全
				- ちなみに、a.example.jpはDomain属性をexample.comにしてCookieをセットすることは出来ない(セッションIDの固定化攻撃の手段となるため)
			- Secure属性
				- Secure属性がついたHTTPS通信の場合にのみサーバに送信される
			- HttpOnly属性
				- HttpOnly属性がついたCookieはJavaScriptからアクセス出来ない
				- HttpOnly属性をつけてもXSSを完全に防ぐことは出来ないが、XSSが難しくなる
- ### 受動的攻撃と同一オリジンポリシー
	- 能動的攻撃と受動的攻撃
		- 能動的攻撃は攻撃者がサーバに直接攻撃をすること
		- 受動的攻撃は攻撃者がサーバを直接攻撃するのではなく、Webサイトの利用者に罠を仕掛けて、罠を閲覧したユーザを通じて攻撃を行う手法
	- ブラウザは受動的攻撃をサンドボックスによって防ぐ
		- サンドボックス内でプログラムを実行することで被害を防ぐ
		- JavaScriptのサンドボックスでは以下のように機能が制限されている
			- ローカルファイルへのアクセスの禁止
			- プリンタなどの資源の利用禁止
			- 異なるオリジンのアクセスの禁止(同一生成元ポリシー)
	- 同一生成元ポリシーが誕生したのは1995年であり、それより前から存在しているものには同一生成元ポリシーは適用されない([参考](https://zenn.dev/qnighy/articles/6ff23c47018380#cors%E3%81%8C%E4%BD%BF%E3%82%8F%E3%82%8C%E3%81%AA%E3%81%84%E3%81%A8%E3%81%8D))
		- Webの仕様が出来る限り既存の文書を壊さないように制定されているため
		- <frame src="...">, <iframe src="...">, <img src="...">, <script src="...">, <link rel="stylesheet" href="...">, <form action="..."> など
		- <script src="...">に同一生成元ポリシーが適用されないことを利用して、XHRの代用としたのがJSONP
			- CORSが登場したことで使われなくなった
- ### CORS(Cross-Origin Resource Sharing)
	- 同一生成元ポリシーの緩和策で、相手側オリジンの許可があれば、相手側オリジンのリソースを取得したり、操作出来るというもの
	- [CORSの仕様はなぜ複雑なのか](https://zenn.dev/qnighy/articles/6ff23c47018380)を見てCORSの仕様を理解する
		- 素朴な仕様
			- 異なるオリジンへのリクエストの場合、ブラウザがリクエストにOriginヘッダを付与する
			- サーバがOriginヘッダを見て、アクセス制御を行う
		- しかしこの仕様には問題がある
			- CORSの登場以前は、同一生成元ポリシーが存在するため、サーバは異なるオリジンからXHRが飛んでくる可能性を考える必要がない
				- そのため既存のサーバはOriginヘッダを見る仕組みになっていない
			- この仕様を導入すると、この仕様を実装していないサーバは、全てのオリジンにリソースの読み取りを許可することになってしまう
		- 次に考えられる仕様は以下のようなもの
			- 異なるオリジンへのリクエストの場合、ブラウザがリクエストにOriginヘッダを付与する
			- サーバは受け取ったOriginヘッダを見て、リソースの取得、操作を許可するなら、Acess-Control-Allow-Originヘッダに、受け取ったOriginヘッダの値を設定して返す
			- ブラウザは受け取ったAcess-Control-Allow-Originヘッダを見て、自身のオリジンが設定されていれば、リソースの読み取りを許可する
			- Access-Control-Allow-Originヘッダが返ってこなかったり、自身のオリジンが設定されていなければ、リソースの読み取りを禁止する
				- レスポンスは返ってきているが、JavaScriptで読み取ることが禁止されている
		- この仕様であれば、この仕様を実装していないサーバは、Access-Control-Allow-Originヘッダを返さないため、リソースは読み取られなくて済む
		- しかし、この仕様を実装していないサーバについて、リソースの操作はされてしまうという問題が依然残っている
		- そこで、本番のリクエストの前にプリフライトリクエストを送信する
			- 異なるオリジンへのリクエストの場合、ブラウザがリクエストにOriginヘッダを付与し、OPTIONSメソッドで送信する(プリフライトリクエスト)
			- サーバは受け取ったOriginヘッダを見て、リソースの取得、操作を許可するなら、Acess-Control-Allow-Originヘッダに、受け取ったOriginヘッダの値を設定して返す
			- ブラウザは受け取ったAcess-Control-Allow-Originヘッダを見て、自身のオリジンが含まれていたら本番のリクエストを送信し、含まれていなければ、本番のリクエストは送信しない(本当はAccess-Control-Allow-MethodsやAccess-Control-Allow-Headersも見ている)
		- この仕様であれば、この仕様を実装していないサーバについても、リソースの操作をされなくて済む
		- しかし、プリフライトリクエストを飛ばすことでRTT1回分のレイテンシが発生することになる
			- プリフライトリクエストのレスポンスをキャッシュすれば良いが、それでもレイテンシを減らしたい
			- ここで、同一生成元ポリシーの制限を受けないformタグのことを考える
				- formタグは元から異なるオリジンへのリクエストを実行可能であり、CSRFトークンの検証などサーバ側の対策が必要だった
				- なので、formタグで送れるようなリクエストに関しては、既にサーバ側で対策がされているだろうということで、formタグで送れるようなリクエストをシンプルリクエストと呼び、シンプルリクエストの場合は、プリフライトリクエストを送信しないことにした
	- 異なるオリジンに対するリクエストには認証に用いられるリクエストヘッダは自動的に送信されない(なぜ)
		- XHRの場合、withCredentialsをtrueにする必要がある
		- さらにサーバのレスポンスヘッダでAccess-Control-Allow-Credentialsがtrueになっていないと、JavaScriptでリソースを読み取ることは禁止される