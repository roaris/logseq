# 署名付きURLについて
- ## 動機
	- PDFをアップロードするサービスがあったとする
	- アップロードしたPDFはダウンロードすることが出来る
	- ログイン機能があって、他のユーザがアップロードしたPDFをダウンロードすることは出来ない
	- サーバ側では、PDFを丸ごとデータベースに保存するのではなく、GCSなどのストレージサービスに保存し、ダウンロードURLのみをデータベースに保持している
	  id:: 64e616c4-3570-4bc6-878f-9fcd5e418eb0
	- PDFをダウンロードするリクエストが飛んできた時、サーバはダウンロードURLをLocationヘッダにセットしてレスポンスを返し、リダイレクトさせることでPDFをダウンロードさせる
		- 例えばGCSにPDFを保存していて、ダウンロードURLが`https://storage.googleapis.com/example-bucket/abc`ならこれをLocationヘッダにセットしてレスポンスを返す
		- ブラウザはLocationヘッダを見て、`https://storage.googleapis.com/example-bucket/abc`にリダイレクトし、このページからPDFがダウンロードされる
		- サーバがGCSと通信してPDFを取得して、このPDFをクライアントに返すという方法も考えられるが、これだとサーバの負担が増えてしまう
	- 悪意のある人は、自分がアップロードしたPDFが`https://storage.googleapis.com/example-bucket/abc`に保存されているのを見て、`https://storage.googleapis.com/example-bucket/def`にアクセスして、他のユーザがアップロードしたPDFが見ようとするかもしれない
	- こういう時に署名付きURLを使う
- ## 仕組み
	- 簡単に言うと...
		- HMACを使う
		- 署名というが、デジタル署名のように秘密鍵を使って暗号化するわけではない
	- まず署名に使う鍵をGCSに登録する
	- PDFをアップロードするリクエストが飛んできたとき、サーバはGCSに署名付きURLを作成するリクエストを投げる
		- リクエスト中で事前に登録しておいた鍵の中でどれを使うかを指定する
		- 署名付きURLが有効である期限をリクエストに含めることが出来る
	- サーバからのリクエストを受けてGCSは署名付きURLを作成する
		- この時のGCSの処理は、 https://github.com/GoogleCloudPlatform/golang-samples/blob/main/cdn/signedurls/signurl.go#L40-L54 を見ると分かる
		- GCPのデモコード？らしいので実際の処理はもっと複雑であるはず
			- SHA-256ではなくSHA-1を使っているのも気になるし(SHA-1は強衝突耐性が破られている)
		- 署名をするURLにクエリパラメータで有効期限と署名に使う鍵の名前を付けたものと、鍵の2つをHMACの入力にする
		- HMACの出力をクエリパラメータで追加して署名付きURLの完成
	- 署名付きURLにアクセスされた時、GCSは署名を検証する
		- クエリパラメータの中に有効期限があるので、それを過ぎていたらエラーを返す
		- クエリパラメータの中に署名に使う鍵の名前があるので、その鍵を引っ張って来て、署名を再作成して、クエリパラメータの中にある署名と比較する
			- 一致していたらOKで、一致していなかったらエラーを返す
			- 有効期限を改竄されていても署名が一致しないので大丈夫
	- https://cloud.google.com/storage/docs/access-control/signed-urls?hl=ja を見るとX-Goog-Algorithmというクエリパラメータに`GOOG4-RSA-SHA256`がセットされている例が書かれている
		- RSAをどこで使うのか謎である
	- LaravelなどのWebフレームワークにも署名付きURLを作成する機能がある([参考](https://readouble.com/laravel/9.x/ja/urls.html))
		- 処理は、 https://github.com/illuminate/routing/blob/master/UrlGenerator.php#L340-L357
		- おそらく上に書いた処理と同様のことをしている
		- 購読終了リンクの作成に使ったりする
			- 購読終了する時にログインしなくて済むのは便利