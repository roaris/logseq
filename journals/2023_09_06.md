# 徳丸本
- ## 4章 Webアプリケーションの機能別に見るセキュリティバグ(続き)
- ### 4.16 Web API実装における脆弱性(続き)
- #### 4.16.5 Web APIのCSRF
	- GETリクエストでCSRFをするのは簡単なので、GETリクエストで重要な処理を行なってはいけない
	- POSTリクエストによるCSRF
		- formタグで送信出来るのはtext/plain, application/x-www-form-urlencoded, multipart/form-dataのどれか
		- API側でこの3つのContent-Typeを想定していて、かつCSRF対策がされていない場合は、formタグを使ってCSRFが可能
		- API側でapplication/jsonを想定している場合、formタグではapplication/jsonを送信出来ないので、CSRF出来ないように思われる
		- しかし、API側でContent-Typeがapplication/jsonであるかの検証をしていない場合、XMLHttpRequestやfetchでContent-Typeをtext/plainなどにした上でJSONを送信することでCSRFが可能となる
			- Content-Typeをtext/plainにすると、プリフライトリクエストが送信されず、いきなり本番リクエストが送信される
			- API側でContent-Typeの検証をせずに、リクエストボディをJSONとしてパースして処理してしまう
			- レスポンスは読み取ることが出来ないが(Access-Control-Allow-Originヘッダに罠サイトのドメインは当然含まれないため)、処理は完了してしまうためCSRFが可能
	- 本の攻撃例、なぜか再現出来ない
		- 罠サイトから送信されるリクエストにCookieがつかない
		- SameSite属性がLaxなので、Cookieが生成されてから2分間は罠サイトからのPOSTリクエストでもCookieがつくはずなのだが、なぜかつかない
	- 対策
		- Content-Typeの検証をする
		- CSRFトークンを使う
			- CSRFトークンの渡し方
				- WebページにhiddenパラメータでCSRFトークンを埋め込む
					- サーバからHTMLを返す場合はこれが出来るけど、APIを使う場合、つまりSPAを使う場合は出来ない気がする(やり方書いてないので分からない)
				- CSRFトークンを返すAPIを用意する
		- 二重送信Cookie
			- 乱数によるトークンをCookieとして保存し、カスタムリクエストヘッダ(X-CSRF-TOKENなど)でCookieの値を送信させる
			- Cookieヘッダの値とカスタムリクエストヘッダの値が一致するかを確認する
				- リクエストヘッダとは別にCookieヘッダでも送信されるので、二重送信Cookieという
			- ヘッダとして送信するためには、JavaScriptで操作出来ないといけないので、CookieのHttpOnly属性は無しにする
			- formタグではカスタムリクエストヘッダをつけることは出来ない
			- XMLHttpRequestやfetchを使う場合でも、カスタムリクエストヘッダがついていることで、プリフライトリクエストが送信され、(サーバ側のプリフライトリクエストの処理がきちんとしていれば)ここで攻撃が失敗する
		- とりあえずカスタムリクエストヘッダをつける
			- 何でも良いからカスタムリクエストヘッダをつけて、サーバ側でカスタムリクエストヘッダがついているかを確認する
			- カスタムリクエストヘッダをつけたことで、プリフライトリクエストが送信されるようになるので、罠サイトからのリクエストの場合、(サーバ側のプリフライトリクエストの処理がきちんとしていれば)ここで攻撃が失敗する
		- jQueryでリクエストを送信する場合は自動でX-Requested-With: XMLHttpRequestというヘッダが付与される
- #### 4.16.6 JSONハイジャック
	- script要素でJSONを受け取っても、どこにも代入されずに消えてしまう
		- そのため、JSONPではサーバから受け取ったデータを処理するために、JSONをコールバック関数の引数にしていた
	- しかし、script要素でJSONを受け取り、それを処理することが出来る方法が存在するらしく、これをJSONハイジャックと呼ぶ
		- 現在はブラウザ側で対策が取られている
	- 対策
		- レスポンスヘッダにX-Content-Type-Options: nosniffを付与する
			- 本来application/jsonはscriptタグで読み込めない
		- カスタムリクエストヘッダの確認
			- scriptタグではカスタムリクエストヘッダを付与することは出来ない
- #### 4.16.7 JSONPの不適切な利用
	- JSONPはCORSのようなアクセス制御が出来ないので、認証が必要な情報をJSONPで返したら駄目で、公開情報の提供にとどめる
		- Refererヘッダを確認することが出来るが、Refererヘッダが送信されないようにしている利用者もいるため、Refererヘッダをアクセス制御に用いるのは適切ではない
	- JSONPの提供側に悪意がある場合は、任意のJavaScriptが実行可能になる
	- 以上の理由からJSONPは利用するべきではなく、どうしても利用するなら、JSONPを提供する側なら公開情報の提供にとどめる、JSONPを利用する側なら提供元が信頼出来る時のみに限る