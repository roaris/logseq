# SC過去問
- ## [平成30年 午後I](https://www.ipa.go.jp/shiken/mondai-kaiotu/gmcbt8000000f01f-att/2018h30a_sc_pm1_qs.pdf)
- ### 問1
	- 設問1
		- (1) a:キ, b:カ, c:ウ, d:ア
		- (2) ウ
		- (3) ?
			- 解答例 : shellコードがDEPで実行禁止にされているスタック領域にあるから
	- 設問2
		- (1)
			- e : canary
			- f : ASLR
		- (2) strcpy
	- 設問3
		- (1)
			- 行番号 : 16
			- 排除できない理由 : ライブラリ関数を使わずに、配列s1へのコピーをしているため
				- 解答例 : ポインタを使って直接メモリ操作しているから
				- まあ良いでしょう
		- (2)
			- どのような問題か : canaryの上書きが誤検知されるという問題
				- 解答例 : メモリ破壊攻撃を防げないこと
			- どのような開発環境の場合に問題となるか : 64ビットOS
				- 解答例 : SSPを適用できないコンパイラを利用する開発環境
	- メモ
		- 「はじめて学ぶバイナリ解析」で一度バッファオーバフローについて学んでいたが、内容を完全に忘却していた(読み直すか)
- ### 問2
	- 設問1 a:ウ, b:ス, c:ソ, d:エ, e:?
		- 解答例 : a:ウ, b:ス, c:セ, d:エ, e:コ
	- 設問2
		- (1) SYN/FIN
			- 解答例 : SYN+ACK
		- (2)
			- (a) : 最後までスキャンするたびに、5分間待機するため
				- 解答例 : パケットがNSMセンサの監視対象外であるため
				- 確かに図1を見ると同一セグメント内の通信はNSMセンサで監視されない
			- (b) : 最後までスキャンが完了したらスキャンを終了するため
				- 解答例 : 同一IPアドレスへのスキャン回数は少ないから
				- 合っていると言っても良い？
	- 設問3
		- (1) PC101, PC321, PC277, PC133, PC340, PC301
		- (2) イ, オ, カ
	- 設問4
		- (1) ?
			- 解答例 : セキュリティ修正プログラムが適用されていること、マルウェア定義ファイルが更新されていること、PCがマルウェアに感染していないこと
		- (2) ?
			- 解答例 : VLANを使い、PC間の通信を禁止する。
	- メモ
		- ワームとは([参考](https://jp.norton.com/blog/malware/worm))
			- マルウェアの一種で、自ら複製を作って感染を拡大する、宿主となるファイルを必要としないという特徴を持つ
			- 感染方法としては、大量のメールを送る方法や、今回の問題のようにIPアドレスに手当たり次第アクセスする方法がある
		- インディケータ情報とは、攻撃者が使用したサーバのIPアドレスやドメイン、マルウェアのハッシュ値などの情報のことで、STIX(?)のXML形式で提供される([参考](https://jpn.nec.com/cybersecurity/blog/210115/index.html))
		- 全二重通信は送信と受信を同時に行える通信方式、半二重通信は送信と受信を同時に行えない通信方式(全二重通信は電話、半二重通信はトランシーバに例えられる)([参考](https://www.m-system.co.jp/mstoday/plan/mame/b_network/9602/index.html))
		- ポートミラーリングとは([参考](https://wa3.i-3-i.info/word16580.html))
			- スイッチングハブにおいて、特定のポートに流れているデータをコピーして別のポートに流す機能
			- 前者のポートをモニターポート、後者のポートをミラーポートと呼ぶ
		- DHCPの仕組み([参考](https://xtech.nikkei.com/atcl/nxt/column/18/00780/062000010/))
			- IPアドレスの割り当てには静的と動的がある
			- 静的はユーザが設定し、動的はクライアントとDHCPサーバが通信し、自動で設定される
			- DHCPサーバは、IPアドレスを割り当てるだけではなく、サブネットマスクやデフォルトゲートウェイ、DNSサーバも設定する
				- AndroidのWifi設定→IP設定で静的を選択すると、これらの設定が手動で出来る
			- 手順
				- 1. DHCP発見パケット(クライアント→DHCPサーバ)
					- DHCPサーバがどこにいるか分からないのでブロードキャストで送信する
				- 2. DHCP提供パケット(クライアント←DHCPサーバ)
					- 割り当てるIPアドレスを送信する
					- ユニキャストで送信する
				- 3. DHCP要求パケット(クライアント→DHCPサーバ)
					- DHCP提供パケットで受け取った情報を使用することを要求する
					- 二つ以上のDHCPサーバから提供を受けた時、他のDHCPサーバには要求しないことを同時に通知するためにブロードキャストで送信する(クライアントは通常一番先に届いたDHCP提供パケットのIPアドレスを使用する)
				- 4. DHCP確認応答パケット(クライアント←DHCPサーバ)
					- サブネットマスク、デフォルトゲートウェイ、DNSサーバなどを送信する
					- ユニキャストで送信する
			- DHCPサーバから提供される情報には有効期間が設定されていて(リース期間という)、これを過ぎると、別のクライアントにIPアドレスが割り当てられる
			- リース期間を延長したい場合は、クライアントからDHCPサーバに再度DHCP要求パケットを送信する
			- DHCPサーバからDHCP確認応答パケットが来たら、リース期間を延長することが出来る
		- TCPの通信の流れ([参考](https://www.infraexpert.com/study/tcpip9.html))
			- TCPヘッダ([参考](https://www.infraexpert.com/study/tcpip8.html))
				- シーケンス番号 : 送信したデータの開始位置、Byte単位
				- 確認応答番号 : 次はここから送ってねという番号、Byte単位
				- コントロールフラグ : SYN, ACK, FINなどのフラグがあり、1である場合に意味を成す(ACKはコネクション確立時のSYNパケット以外は必ず1になる)
			- コネクションの確立(3ウェイハンドシェイク)
				- 1. A→B (接続を開始しても良い?)
					- SYN=1, ACK=0(SYN)
					- シーケンス番号1234
						- シーケンス番号はランダムに決められる、適当に1234とする
				- 2. A←B (OK! こちらからも接続を開始しても良い?)
					- SYN=1, ACK=1(SYN+ACK)
					- シーケンス番号4321, 確認応答番号1235
						- シーケンス番号はランダムに決められる、適当に4321とする
						- SYNパケットは1Byteとして扱われ、確認応答番号は1234に1を足した1235となる
				- 3. A→B (OK!)
					- SYN=0, ACK=1(ACK)
					- 確認応答番号4322
			- データのやり取り
				- 1. A→B (100Byteのデータを送信)
					- シーケンス番号1235, 確認応答番号4322
				- 2. A←B (1300Byteのデータを送信)
					- シーケンス番号4322, 確認応答番号1335
				- 3. A→B (200Byteのデータを送信)
					- シーケンス番号1335, 確認応答番号5622
				- 4. A←B (1300Byteのデータを送信)
					- シーケンス番号5622, 確認応答番号1535
			- コネクションの切断
				- 1. A←B (切断して良い?)
					- ACK=1, FIN=1
					- シーケンス番号6922, 確認応答番号1535
				- 2. A→B (OK!)
					- ACK=1, FIN=0
					- シーケンス番号1535, 確認応答番号6923
					- FINパケットは1Byteとして扱われ、確認応答番号は6922に1を足した6923となる
				- 3. A→B (こちらからも切断して良い?)
					- ACK=1, FIN=1
					- シーケンス番号1535, 確認応答番号6923
				- 4. A←B (OK!)
					- ACK=1, FIN=0
					- シーケンス番号6923, 確認応答番号1536
			- コネクションの切断、2番目と3番目まとめて良い気がするけど、なんで別々なんだろう
			- todo: 再送処理を勉強