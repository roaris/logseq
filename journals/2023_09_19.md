# レインボーテーブルについて
- ## 概要
	- SQLインジェクションなどでDBに保存されているパスワードのハッシュ値を手に入れたとする
	- このハッシュ値から元のパスワードを求めたい
	- 単純な方法としては(パスワード、ハッシュ値)のペアを事前に大量に用意しておくというものである
	- しかし、この方法では莫大な記憶領域が必要になるという問題が存在する
		- パスワードの集合が正規表現で[a-zA-Z0-9]{1,12}であるとすると、62^12(=3.2x10^21)個ほどのペアを記録しておかないといけない
	- レインボーテーブルはこの問題を解決する(より少ない記憶領域で元の平文を手に入れることが出来る)
- ## 仕組み
- ### 還元関数について
	- 突然だが、還元関数というものを考える
	- 還元関数はハッシュ値を入力として、適当な処理をして、パスワードの候補を出力する関数のことである
		- 出力がパスワードの候補であれば、どんな関数でも良い
			- パスワードの集合が[a-zA-Z0-9]{1,12}なのに`abc!`(!が使われている)を出力したり、`abcdefghijklmn`(14文字)を出力したりする関数は駄目
		- パスワードの集合が[a-zA-Z0-9]{1,12}である場合は、ハッシュ値を10進数として解釈した値を62^12で割った余りを62進数として解釈した値を出力する還元関数などが考えられる
			- 例えばハッシュ値が16進数で`AB`だとすると、10進数で解釈した値は171となる
			- 171 = 62 x 2 + 47 であり、0→a, ..., 25→z, 26→A, ..., 51→Z, 52→0, ..., 61→9と対応付けし、62進数で解釈すると、`cV`となる
			- つまり、この還元関数は`AB`を受け取ったら`cV`を返す、他の入力についても同様
- ### レインボーテーブルの作成
	- $N$と$M$という正の整数のパラメータを用意する
	- [a-zA-Z0-9]{1,12}からランダムに$N$個選択し、これらを$P_{1,1}, \ldots, P_{N,1}$とする
		- 集合を実際に作る必要はなく、1~12の中からランダムに1つ選択し(これを$x$とする)、[a-zA-Z0-9]の中から$x$回ランダムに選択すれば良い
	- $P_{1,1}, \ldots, P_{N,1}$から、
		- $P_{1,1} \rightarrow C_{1,1} \rightarrow P_{1,2} \rightarrow C_{1,2} \rightarrow \ldots \rightarrow P_{1,M} \rightarrow C_{1,M}$
		- $\vdots$
		- $P_{N,1} \rightarrow C_{N,1} \rightarrow P_{N,2} \rightarrow C_{N,2} \rightarrow \ldots \rightarrow P_{N,M} \rightarrow C_{N,M}$
		- という列を作り出す
		- $C_{i,j} = H(P_{i,j}), P_{i,j} = R(C_{i,j-1})$と計算される
			- $H$はハッシュ関数、$R$は還元関数である
		- 簡単に言うと、パスワードとハッシュ値を交互に繰り返した列を$N$個作る
			- 一つの列のことをチェインと呼ぶ
			- $N$はチェイン数、$M$はチェインの長さを表すパラメータである
			- $N$個のチェインを並べた時に虹みたく見えるからレインボーテーブルと呼ぶのだと思う
	- レインボーテーブルでは、全ての列を丸々記憶するのではなく、$(P_{1,1}, C_{1,M}), \ldots, (P_{N,1}, C_{N,M})$だけを記憶する
		- 記憶する値の個数は$2N$個である
		- 概要で述べた単純な方法では$2NM$個保存することになる
	- $(P_{1,1}, C_{1,M}), \ldots, (P_{N,1}, C_{N,M})$を使って、ハッシュ値から元のパスワードを求める
		- 重要な点として、元のパスワードが$P_{1,1}, \ldots, P_{1,M}, \ldots, P_{N,1}, \ldots, P_{N,M}$に含まれない場合は失敗する
		- これは概要で述べた単純な方法でも同じことである
		- もし一つのチェインの中で、$P_{i,j}$と$P_{i,k}$が同じ値になってしまうと、$P_{i,j+1}$と$P_{i,k+1}$が同じ、$P_{i,j+2}$と$P_{i,k+2}$が同じ、...という風に記憶領域の無駄遣いになってしまう
		- そこで、還元関数を$R_1, \ldots, R_{M-1}$の$M-1$個用意する
		- $P_{i,2}=R_{1}(C_{i,1}), \ldots, P_{i,M}=R_{M-1}(C_{i,M-1})$のように計算する
		- $R_i$は上に書いた還元関数の例を少し修正することで設計出来る
			- ハッシュ値を10進数として解釈した値に$i$を加えて、62^12で割った余りを62進数として解釈した値を出力する([参考](https://crypto.stackexchange.com/questions/37832/how-to-create-reduction-functions-in-rainbow-tables))
		- これによって、$P_{i,j}$と$P_{i,k}$が同じ値になってしまったとしても、上で説明したような記憶領域の無駄遣いを無くすことが出来る
- ### レインボーテーブルを使ったパスワードの特定
	- 対象のハッシュ値を$C_x$とする
	- まずパスワードが$P_{1,M}, \ldots, P_{N,M}$の中にないかを調べる
		- これは$C_x$が$C_{1,M}, \ldots, C_{N,M}$の中に含まれているかをチェックすれば良い
		- もし$C_x = C_{i,M}$ならば、パスワードは$P_{i,M}$ということになる
		- $P_{i,M}$は、$P_{i,1}$から順にハッシュ関数と還元関数を適用していくことで求められる
	- 次にパスワードが$P_{1,M-1}, \ldots, P_{N,M-1}$の中にないかを調べる
		- これは$H(R_{M-1}(C_x))$が$C_{1,M}, \ldots, C_{N,M}$の中に含まれているかをチェックすれば良い
		- もし$H(R_{M-1}(C_x)) = C_{i,M}$ならば、パスワードは$P_{i,M-1}$ということになる
		- $P_{i,M-1}$は、$P_{i,1}$から順にハッシュ関数と還元関数を適用していくことで求められる
	- 次にパスワードが$P_{1,M-2}, \ldots, P_{N,M-2}$の中にないかを調べる
		- これは$H(R_{M-1}(H(R_{M-2}(C_x))))$が$C_{1,M}, \ldots, C_{N,M}$の中に含まれているかをチェックすれば良い
		- もし$H(R_{M-1}(H(R_{M-2}(C_x)))) = C_{i,M}$ならば、パスワードは$P_{i,M-2}$ということになる
		- $P_{i,M-2}$は、$P_{i,1}$から順にハッシュ関数と還元関数を適用していくことで求められる
	- 以下同様である
- ### 効率
	- 単純な方法と比べて、記憶領域が削減されるのは既に述べた通りである
	- では計算時間はどうなるか
	- ハッシュ関数と還元関数の計算量を定数とする
	- 前計算については、単純な方法、レインボーテーブルともに$O(NM)$である
		- ただし、レインボーテーブルの方が定数倍が重い
	- パスワードの特定は、ファイル読み込みと特定部分に分かれる
		- ファイル読み込みは、単純な方法が$O(NM)$、レインボーテーブルが$O(N)$である
		- 特定部分は、単純な方法が$O(NM)$、レインボーテーブルについては$O(M(N+M))$である
	- レインボーテーブルの$N$と$M$にはトレードオフがある
		- $M$を小さくして$N$を大きくすると、特定部分の計算時間は短くなるが、必要な記憶領域が増え、$M$を大きくして$N$を小さくすると、特定部分の計算時間は長くなるが、必要な記憶領域が減るというトレードオフがある(計算時間がどうなるかは、$M$を$x$倍し、$N$を$\frac{1}{x}$倍するとどうなるかを考えると分かる)
- ## 実装
	- https://github.com/roaris/rainbow-table
-
- # 徳丸本
- ## 5章 代表的なセキュリティ機能(続き)
- ### 5.1 認証(続き)
- #### 5.1.4 自動ログイン
	- ログインフォームに、「ログイン状態を保持する」というチェックボックスがついていることがある
		- 自分がパッと思いついたのは[codeforces](https://codeforces.com/enter)ぐらい
		- デフォルトでログイン状態を保持するものが多い
	- 実装方法
		- ログイン時のリクエストに、「ログイン状態を保持する」がチェックされたかのフラグを含める
		- セッションIDのCookieのExpires属性を、フラグがfalseならSessionに、trueなら1週間後などに設定する
		- ログイン検証時にExpires属性がSessionでないなら(=ログイン状態が保持されているなら)、現在時刻 + 1週間後などにExpires属性を更新する
	- Expires属性がSessionというのは、ブラウザを閉じるとCookieが削除されることを意味している
		- ブラウザの設定によっては、ブラウザを閉じてもCookieが削除されないことがある([参考](https://www.secuavail.com/kb/practical-post/cookie-google-chrome/))
	- codeforcesがどのようになっているかを確認してみる
		- ログイン前からJSESSIONIDという名前のCookieがある
		- チェックをつけずにログインするとJSESSIONIDに認証情報が紐づくと考えられる(JSESSIONIDを削除するとログアウトするため)
			- 新しい値が発行されないので、session fixationが可能かと思ったが、HttpOnly属性がついているので出来ない気がする
		- JSESSIONIDのExpires属性はSessionになっている
		- ブラウザを閉じるとJSESSIONIDが削除されるので、ログアウトする
		- チェックをつけてログインすると、JSESSIONIDのExpires属性が変わるのではなく、X-Userという名前のCookieがセットされ、このCookieのExpires属性が30日後になっている
		- リロードしてもX-UserのExpires属性は更新されないので、30日後になったらログアウトする
	- PHPでは[session_set_cookie_params](https://www.php.net/manual/ja/function.session-set-cookie-params.php)でセッションIDのCookieのExpires属性を設定出来るが、出来ない言語もあり、その場合はトークンを使って実装する
		- ログイン時の処理
			- 「ログイン状態を保持する」のフラグがtrueならトークンを生成する
			- トークンとユーザIDを紐付けてデータベースに保存する
			- トークンをCookieにセットする
				- このCookieの有効期限は自由に設定出来る
			- 本にはトークンとユーザIDに加えて有効期限も含めてデータベースに保存すると書かれているが、Expires属性があるので有効期限を保存する必要はないように思う
		- ログイン検証時の処理
			- セッションIDのCookieの有効期限が切れていなかったら成功
			- そうでない場合、以下の条件を全て満たせば成功、そうでないなら失敗とする
				- トークンのCookieがリクエストに含まれる
				- トークンのCookieの有効期限が切れていない
				- データベースにトークンが存在する
			- トークンによって成功した場合は、古いトークンをデータベースから削除して、新しいトークンをデータベースに保存 & Cookieにセットする
				- 古いトークンのままだと漏洩時のリスクが高い
	- 複数のサーバにまたがって認証情報を共有したい場合は、SSOやOpenID Connectを利用する([参考](https://www.mobi-connect.net/blog/single-sign-on/))
	- 自動ログインのデメリットとして、認証状態が長く続くために、XSSやCSRFなどの受動的攻撃のリスクが高くなることがある
		- 再認証を要求することでこのリスクを低減することが出来る
- #### 5.1.5 ログインフォーム
	- パスワード入力欄はマスク表示することで、ショルダーハックの対策となる
		- 利用者がかえって簡単な(=危険な)パスワードを入力してしまう可能性があるため、マスク表示を解除出来るようになっているサイトが多い
	- HTTPSでパスワードを送信するだけでなく、ログインフォームもHTTPSでやり取りする必要がある([参考](https://dev.mozilla.jp/2016/02/no-more-passwords-over-http-please/))
		- HTTPでやり取りをすると中間者攻撃でログインフォームを改竄することが可能
		- 送信ボタンを押した時にユーザ名とパスワードを攻撃者のサーバに送信するなど
		- HTTPSを使う場合はブラウザが証明書を確認するので、中間者攻撃を防げる
- #### 5.1.6 エラーメッセージの要件
	- ログイン時のエラーメッセージとして、「指定したユーザは存在しません」「パスワードが間違っています」などはセキュリティの面で不適切
		- パスワード試行がやりやすくなるため
		- IDとパスワードがそれぞれ1万通りずつある場合、IDとパスワードのどちらが間違いか分からない場合は、最悪1万x1万で1億通り試す必要があるが、どちらが間違いか分かる場合は、まずIDを変化させていき、存在するIDが見つかったらパスワードを変化させていくことで、2万通りほどで試すことが出来る
	- アカウントロック時のエラーメッセージは「IDまたはパスワードが違うか、アカウントがロックされています」とする
		- このままだと何が原因でログインが失敗したのか分からない
		- アカウントがロックされた場合は本人にメール通知を行う
		- さらに注意書きとして、アカウントがロックされた場合はメールに通知が飛ぶことを書いておく
	- 実際はユーザビリティの観点からどちらが間違っているか分かるようになっているサイトも増えている
		- 例えば、Googleアカウントのログイン
		- メールアドレスとパスワードを二段階で入力するようになっている
			- なぜ二段階で入力させるのかというと、メールアドレスからIDプロバイダを判別して、当該プロバイダーのログイン画面に遷移させるため([参考](https://jp.quora.com/Google-Slack-nado-no-saisentan-no-sa-bisu-no-roguin-fo-mu-de-me-ruadoresu-ran-to-pasuwa-do-ran-wo-wakeru-you-ni-na-tsu-ta-no-ha-naze-desu-ka))
- #### 5.1.7 ログアウト機能
	- ログアウト処理は副作用があるのでPOSTメソッドでリクエストする
	- ログアウト処理ではセッションを破棄する
	- 必要な場合はCSRF対策をする
- ### 5.2 アカウント管理
- #### 5.2.1 ユーザ登録
	- メールアドレスの受信確認
		- メールアドレスの登録、変更時には、入力されたメールアドレスに送信されるメールを利用者自身が受信出来ることを確認するべき
			- パスワード変更やアカウントロックの発生時にメール通知をするようにしていても、間違ったメールアドレスが登録されていると、利用者にメールが届かず、気づけないため
		- 以下の2つの方法がある
			- メールにトークン付きURLを添付して、そのURLを開かれたらOKとする
				- トークンとメールアドレスの対応をデータベースなどで保存しておく
				- URLを開くだけで済むので、ユーザの操作性は良いが、メールに記載されたURLを開かせるというのがフィッシングの観点で望ましくない
			- メールアドレスを入力した後、トークン入力画面に遷移し、メールで送信されるトークンを入力されたらOKとする
				- トークンはセッション変数に保持しておいて、入力されたトークンとセッション変数に保持されたトークンを比較する
				- ユーザの入力を必要とするが、フィッシングの観点では望ましい
	- ユーザIDの重複防止
		- リクエスト同時送信などで、同一のユーザIDで複数のアカウントを作成出来る場合がある
		- ユーザIDに一意性制約をつけるか、それが出来ない場合は排他制御を行う
		- 同じユーザIDのアカウントが複数存在すると誤った権限が付与されることがある([参考](https://blog.tokumaru.org/2015/06/column-sql-truncation-vulnerability.html))
	- ユーザの自動登録への対処
		- Googleアカウントのようなメールサービスでは、ユーザを自動操作で大量に作成して、迷惑メール送信の送信元として利用されることがある
		- CAPTCHA(Completely Automated Public Turing test to tell Computers and Humans Apart)を利用することで対策する
			- チェックボックスや、ボットが識別出来ないような湾曲した文字列などを利用する
			- チェックボックスではマウスの動きから人間か自動操作かを判別している
			- 湾曲した文字列の方は人間でも識別出来ない時があるので、音声で代替出来るサイトが増えている
			- reCAPTCHAはCAPTCHAを高度にしたものらしい
- #### 5.2.2 パスワード変更
	- パスワード変更時には現在のパスワードを入力してもらう(再認証)と、セッションハイジャックされた時のパスワード変更やCSRFの対策となる
	- パスワード変更時はメール通知をすることで、第三者に不正にパスワードを変更された場合でも気づくことが出来る
	- パスワード変更処理でSQLインジェクションが可能な場合、再認証を回避してパスワードを変更したり、別ユーザのパスワードを変更したり、全ユーザのパスワードを変更出来たりする
	- パスワード変更処理でCSRFが可能な場合、第三者に不正にパスワードを変更された後に、変更後のパスワードを使って不正ログインされてしまう
- #### 5.2.3 メールアドレスの変更
	- セッションハイジャック、CSRF、SQLインジェクションなどで不正にメールアドレスを変更される場合がある
	- 不正にメールアドレスを変更されると、パスワードリセット機能を使ってパスワードを変更されてしまうことに繋がる
	- 対策としては、新規メールアドレスに対する受信確認(メールアドレスの誤入力を防ぐ)、再認証、メール通知がある
		- メール通知は新旧両方のメールアドレスに対して行う
		- 旧アドレスに通知をするのは、第三者に不正にメールアドレスを変更された時に、気付けるようにするため
		- 受信確認をするのであれば、新アドレスに通知をする理由はない気がする
- #### 5.2.4 パスワードリセット
	- 管理者向けパスワードリセット機能
		- 利用者がパスワードを忘れた時に管理者に問い合わせて対処してもらう時に利用する
		- 元々のパスワードを表示してはいけない(管理者による悪用が考えられるので)
		- 以下の順序で運用する
			- 問い合わせを受け付け、利用者の本人確認を行う(電話か書類の郵送など)
			- 管理者がパスワードをリセットし、利用者に仮パスワードを伝える
			- 利用者は仮パスワードでログインし、直ちにパスワードを変更する
		- 仮パスワードはメールで伝える(電話だと、管理者に悪用されるのではという懸念が生まれたり、利用者を装って成りすまされる可能性があるため)
		- 仮パスワードは即座に変更するべきなので、仮パスワードでログインした場合はパスワードの変更だけを行えるようにする
	- 利用者向けパスワードリセット機能
		- 利用者が自らパスワードをリセットするための機能
		- まずは登録済みメールアドレスにメールを送信する
		- その後は以下の方法が考えられる
			- 現在のパスワードをメールで通知する
				- パスワードがハッシュ化されて保存されていないという不安を持たせる
				- メールが盗聴された時にパスワードが不正利用される
			- パスワード変更画面のURLをメールで通知する
				- フィッシングの観点で望ましくない
			- 仮パスワードを発行してメールで通知する
				- メールが盗聴されて、第三者が仮パスワードを使ってパスワードを設定したとしても、利用者にメール通知されるようになっていたら気づける
				- 仮パスワードでログインした場合はパスワードの変更だけを行えるようにする
				- メール送信前に認証を追加し、二段階認証をするとより安全になる
			- パスワード変更画面に直接遷移する
				- メールで送信されるトークンを入力したら、新しいパスワードの入力画面に遷移する
				- トークンに対するブルートフォース攻撃を防止するために、繰り返し間違えたらロックアウトする必要がある
				- 先にトークンの確認をしていれば、二段階認証をする必要はないと本には書いてあるが、メールアドレスが攻撃者のものに変更されている場合は、SMS認証などを追加することで、パスワードリセットを防ぐことが出来るはず
- #### 5.2.5 アカウントの停止
	- 利用者から依頼された場合(PCを盗まれた、心当たりのないパスワード変更通知メールを受け取ったなど)や不正アクセスを受けている場合は、アカウントを停止する
	- アカウントの停止、再開は管理者向け機能として実装し、本人確認の後に実行する
- #### 5.2.6 アカウントの削除
	- アカウントの削除は、通常取り消せない処理なので行わない
- ### 5.3 認可
- #### 5.3.1 認可とは
	- 認証された利用者に対して権限を与えること
		- 利用者本人の個人情報の閲覧や、利用者本人の設定変更など
	- 認可制御に不備があると、個人情報漏洩や権限の悪用に直結する
- #### 5.3.2 認可不備の典型例
	- URLを知っていると認証無しで情報が閲覧可能
		- 会員限定のコンテンツなど
		- アクセスのための導線がなくてもURLを直打ちすることで閲覧出来ることがある
	- リソースのIDを変更すると権限外の情報が閲覧、編集出来る
		- 自分が所属していないグループの情報の閲覧や、他のユーザが作成したリソースの編集など
		- リソースのIDだけでなくPOSTパラメータも対象
	- メニューの表示・非表示のみで制御している
		- 一般ユーザとしてログインした時に、管理者用の画面へのリンクが非表示になるとしても、認可不備があると、URLを推測して管理者用の画面で操作が実行される、など
		- URLの推測は以下のように行う
			- URL中のアルファベットや数値をずらす
			- admin, root, manageなど管理者用の画面のURLに使われそうな単語を試す
			- 元々権限があった人が権限が無くなった後に試す
			- オープンソースソフトウェアを使っている場合は、ソースコードやマニュアルから推測
	- hiddenパラメータやCookieに権限情報を保持している
		- userkindという名前のCookieにadminを設定するなど
	- 権限情報をセッション変数に保持することで対策する
	- URLに秘密情報を埋め込むことで対策することも出来るが、秘密情報の送信はPOSTメソッドで行うべきで実際に以下のようなリスクが存在する
		- RefererによるURLの漏洩
		- 利用者がSNSでURLを公開してしまう
		- URLが検索エンジンに登録される
		- アドレスバーからURLを覗き見される
	- やむを得ずURLに秘密情報を埋め込む場合は、アクセス可能な時間を極力短くした上で、URLを公開してはならないことを利用者に注意喚起する
		- 署名付きURLでは有効期限を設定することが出来る
- # Misc
	- Column SQL Truncation([参考1](https://blog.tokumaru.org/2015/06/column-sql-truncation-vulnerability.html), [参考2](https://blog.hamayanhamayan.com/entry/2019/06/08/115524))