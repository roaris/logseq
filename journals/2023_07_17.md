- # 暗号技術入門
- ## 第4章 ブロック暗号のモード(続き)
	- パディングオラクル攻撃
		- パディングの内容を少しずつ変化させて、暗号文を送信する
			- 復号しないと出来ないのでは？
		- 受信者は正しく平文に復号化出来なかった場合にエラーを返すので、これを使って平文の情報を得る
			- ErrorベースのSQLインジェクションに似ていると思った
	- CFB(Cipher FeedBack)
		- 平文ブロックと、1つ前の暗号文ブロックを暗号化したもののXORで暗号文ブロックを生成
			- 1つ目の暗号文ブロックは、1つ目の平文ブロックと、IVを暗号化したもののXORで生成
			- ECBやCBCと異なり、平文ブロックと暗号文ブロックの間に暗号化は挟まっていない
		- 復号化は暗号文ブロックと、1つ前の暗号文ブロックを暗号化したもののXORを取る
		- 再生攻撃(replay attack)が可能
			- 連続する暗号文ブロックを過去のもので置き換えることで、復号化して得られる平文ブロックを、過去の平文ブロックで置き換えることが出来る
	- OFB(Output FeedBack)
		- 平文ブロックと、IVを繰り返し暗号化したもののXORで暗号文ブロックを生成
			- 1つ目の暗号文ブロックは、1つ目の平文ブロックと、IVを暗号化したもののXORで生成
			- 2つ目の暗号文ブロックは、2つ目の平文ブロックと、IVを2回暗号化したもののXORで生成
		- 平文ブロックと、暗号アルゴリズムの出力をXORするという点でCFBと似ている
			- 暗号アルゴリズムへの入力が、1つ前の暗号文ブロックになっているのがCFBで(CipherをFeedBack)、暗号アルゴリズムの1つ前の出力になっているのがOFB(OutputをFeedback)
		- 前もって暗号アルゴリズムをぐるぐる回しておいて、XORするためのビット列を準備しておけば、後は平文ブロックとXORを取る作業だけ
			- XORを取る操作は非常に高速 & 平文ブロック毎に並列に計算することも可能
		- 暗号文ブロックのビットを反転させると、対応する平文のビットが反転する → 意図した改竄が可能
	- CTR(CounTeR)
		- 平文ブロックと、1ずつ増加していくカウンタを暗号化したもののXORで暗号文ブロックを生成
			- カウンタの初期値は、暗号化のたびに異なる値(ノンス: nonce)を元に作成
				- ブロック長が16バイトの時のカウンタの例(前半8バイトがnonce)
				- 66 1F 98 CD 37 A3 8B 4B 00 00 00 00 00 00 00 01 (平文ブロック1用のカウンタ)
				- 66 1F 98 CD 37 A3 8B 4B 00 00 00 00 00 00 00 02 (平文ブロック2用のカウンタ)
		- OFBとは異なり、XORするためのビット列の作成も並列に行うことが出来る
			- カウンタはnonceとブロック番号からすぐ求められるため
		- OFB同様、意図した改竄が可能
- ## 第5章 公開鍵暗号
- ### 鍵配送問題
	- 共通鍵暗号では、暗号文と鍵の両方を送信してしまったら、盗聴者にも復号されてしまう
	- 鍵配送問題の解決策として、鍵の事前共有、鍵配布センター、Diffie-Hellman鍵交換、公開鍵暗号がある
- ### 鍵配布センター
	- 社員が鍵配布センターに自分用の鍵を持っている
		- 他の社員の鍵を見れてはいけない
	- AliceからBobへの通信
		- 鍵配布センターは擬似乱数生成器を使って、セッション鍵を作成
		- 鍵配布センターはAliceの鍵を使って、セッション鍵を暗号化し、Aliceに送信 & Bobの鍵を使って、セッション鍵を暗号化し、Bobに送信
		- AliceとBobは鍵配布センターから来た暗号化されたセッション鍵を、自身の鍵で復号化する
		- 復号化したセッション鍵でやり取りする
	- 欠点
		- 社員が暗号通信をするたびに上記の処理をしなければいけない → 負荷大
		- 鍵配布センターに侵入されて、社員の鍵を盗まれると、会社内の全ての通信が解読されてしまう
- ### 公開鍵暗号
	- 暗号化の鍵と復号化の鍵を分ける
		- 暗号化のための鍵が公開鍵で、復号化のための鍵が秘密鍵
	- 公開鍵のデファクトスタンダードはRSA暗号
		- RSA暗号の前にナップサック暗号が作られたが、後になって安全でないことが分かった
		- 他にもElGamal方式、Rabin方式、楕円曲線暗号がある
	- 公開鍵暗号でも解決できない問題
		- 入手した公開鍵が、本当に正しい公開鍵であるか判断できない(中間者攻撃に繋がる)
		- 共通鍵暗号に比べて、処理速度が何百倍も遅い
- ### RSA暗号
	- 暗号文 = 平文^E mod N
		- これだけで暗号化出来る
		- (E, N)が公開鍵
		- mod N を取るため、平文はN未満の数でないといけない
	- 平文 = 暗号文^D mod N
		- これだけで復号化出来る
		- (D, N)が秘密鍵
	- 鍵ペア(=N, E, D)の作成
		- Nを求める
			- 大きい素数p, qの積をNとする
			- p, qが小さすぎると解読が容易になってしまうし、大きすぎると処理時間が長くなる
			- 例えば、大きさを1024ビットにするなら、1024ビットの大きさを持つ数を擬似乱数生成器で作成し、その数が素数であるかを確かめる
				- 素因数分解できるかどうかを調べるのではなく、フェルマーテストやミラー・ラビンテストを用いる
		- Lを求める(鍵ペアの生成にのみ必要)
			- p-1とq-1の最小公倍数をLとする
		- Eを求める
			- Eは、1 < E < L と gcd(E, L) = 1 を満たす
			- 擬似乱数生成器で(1, L)の範囲の数を生成し、その数とLの最大公約数が1であるかをユークリッドの互助法で調べる
		- Dを求める
			- Dは、1 < D < L と E x D mod L = 1 を満たす
	- RSAへの攻撃
		- 暗号文から平文を求める
			- 暗号文 = 平文 ^ E なら対数を求める問題になる
			- mod Nがつくことで、離散対数を求める問題になる
				- 離散対数を求める高速な方法は知られていない
		- ブルートフォースでDを見つける
			- Dが大きい(2048ビット以上の大きさに出来る)ため極めて困難
		- 公開鍵であるEとNからDを求める
			- E x D mod L = 1 が成り立つ
			- L = lcm(p-1, q-1)だから、Dを求めるためにはNを素因数分解して、pとqを求める必要がある
			- 大きな数の素因数分解を高速に行う方法は知られていない
			- 素因数分解をしなくても、擬似乱数生成器の質が悪いと、pとqが推測される可能性がある
- 中間者攻撃
	- AliceからBobにメッセージを送信する時に、Malloryが入り込む
	- AliceがBobの公開鍵を要求し、BobがAliceに公開鍵を送信する
		- この時、MalloryはBobの公開鍵を手元に保存し、AliceにはMallory自身の公開鍵を送信する
		- AliceはMalloryの公開鍵をBobの公開鍵だと思い込む
	- AliceからBobへのメッセージは、Malloryの公開鍵で暗号化されているため、Malloryは復号化出来る
	- MalloryはBobの公開鍵を持っているので、AliceからBobへのメッセージを復号化し、改竄し、Bobの公開鍵で暗号化し、Bobに送信することが出来る
- 選択暗号文攻撃
	- 攻撃者が復号オラクル(任意の暗号文を復号してくれるサービス)を利用できると仮定した攻撃
		- 攻撃対象となる暗号文に対しては復号オラクルを用いることは出来ないと仮定
		- 復号オラクルは現実には存在しないが、攻撃者が偽物の暗号文をサーバに送信し、そのエラーメッセージが返ってくると、サーバが復号オラクルに似た働きをしてしまう
	- 正しい平文を知っている人でなければ作れない暗号文であることを判定すれば良い → RSA-OAEP
	- RSA-OAEP
		- 平文の前に、平文のハッシュ値と決まった個数の0などから作った認証情報を追加し、その後にRSAで暗号化する
		- 復号化した後に、先頭に正しい認証情報が現れなければ、"decryption error"という一定のエラーメッセージを返す(毎回同じエラーメッセージであるため、サーバは復号オラクルとしての役割は持たない)