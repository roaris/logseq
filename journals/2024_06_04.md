# malloc / free の勉強(続き)
	- https://www.youtube.com/watch?v=0-vWT-t0UHg
	- https://www.slideshare.net/slideshow/glibc-malloc/8555290
	- p29 ~ p31
		- first fitではなく、best fitを考える
			- best fitとは、要求されたサイズよりも大きい領域の中で、最も小さい領域を割り当てる方式([参考](https://e-words.jp/w/%E3%83%99%E3%82%B9%E3%83%88%E3%83%95%E3%82%A3%E3%83%83%E3%83%88%E6%96%B9%E5%BC%8F.html))
		- best fitのために、free_listをアドレス順ではなく、空き領域のサイズ順に並べる → 本末転倒
			- freeの時に隣接する領域と併合することが出来なくなり、余計にフラグメンテーションが進む
	- p32
		- 矢印が分かりづらいので、動画の方を見ると良い
		- free_listは空き領域のサイズ順に並んでいるのは変わらなくて、mallocした領域のヘッダ部分にprev_sizeとsizeを持たせることで、freeの時に併合出来るようにしたということ?
		- fd, bkについて
			- https://hackmd.io/@bdEUI2sLQBucW3mIi07cqw/Hk18I5UbU
			- fdがfree_listの次の要素を指すポインタ、bkがfree_listの前の要素を指すポインタかな
			- fdはfowardの略で、bkがbackwardの略
			- 双方向にしているのには理由がある?古典的mallocでは片方向だったのでは?
	- p33
		- 良くなったところ
			- freeがO(1)になった
				- p12のfreeだとfree_listの長さをnとして、O(n)だったが、今回の方法ではprev_sizeとsizeを使うことでO(1)でfree出来る
			- free_listが空き領域のサイズ順に並んでいるので、best_fitが出来る
		- 悪くなったところ
			- mallocがO(1)からO(n)になった
				- first fitからbest fitにしたら効率悪くなるのは仕方無さそうに思える
			- ヘッダサイズが増えて空間効率ダウン
	- p35
		- ヘッダサイズを減らすことを考える
		- mallocした領域のヘッダ部分にbkとfdは必要ない
	- p36 ~ p38
		- 前の領域が使用されているなら、prev_sizeを省略したい
			- 前の領域が使用されているなら、free時に前の領域と併合することはないので、prev_sizeは不要
			- 前の領域が使用されていないなら常に併合可能であり、初めからprev_sizeはいらないのでは?と思った
		- 32bitシステムのポインタは下位2ビットが絶対0
			- 4バイトアラインメントが理由
			- 4バイトアラインメントとは([参考](https://qiita.com/hoboaki/items/46700f03b522193e9747))
				- メモリアドレスを4の倍数にすること
				- アドレス毎に1バイトなので、データとデータの間隔が4バイトの倍数になることを意味する
				- アドレスの下位ビットが0になるので、ここに付加情報を加えることが出来る
		- glibc mallocではメモリアドレスが8の倍数になるため、下位3ビットが0
		- sizeメンバは、ポインタの差分なので、これも下位3ビットが0
		- sizeの最下位ビットを、前の領域が使用されているか否かのフラグに用いる
		- このフラグが1なら(=前の領域が使用されている)、prev_sizeを省略する
		- p38について、free_listの要素のヘッダにはprev_sizeとsizeは不要な気がするのだが、存在しているのは何故だろうか?
	- p39
		- free_listの要素のヘッダにはfdとbkがあるが、mallocした領域のヘッダ部分にfdとbkは不要なので、ユーザに使われるようになる
	- p40
		- mallocした領域のヘッダ部分にfdとbkがなかったが、freeしたタイミングでfdとbkを書き込む
		- freeした領域の次の領域が使用されているなら、その領域のヘッダのsizeの最下位ビットを1から0に変更し、ヘッダにprev_sizeを書き込む