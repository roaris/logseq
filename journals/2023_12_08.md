# 詳解セキュリティコンテスト
- ## Part4 Reversing
- ### 24章 アセンブリ言語(続き)
	- lea命令([参考1](https://qiita.com/kaito_tateyama/items/89272098f4b286b64115#%E5%91%BD%E4%BB%A4)、[参考2](https://qiita.com/nirasan/items/65e8107ae21fcc36d0c9#mov-%E3%81%A8-lea-%E3%81%AE%E9%81%95%E3%81%84%E3%81%AF))
		- アドレスを代入するための命令
		- leaはload effective addressの略
		- lea rax, [0x602060]はraxレジスタに0x602060を代入する(0x602060へのアクセスは行われない)
		- lea命令を使うと、[]の中でレジスタと即値を使った計算が出来る
		- lea rax, [ebx+8]
			- これをlea命令を使わずに書くと、mov rax, ebx → add rax, 8となる
	- inc命令、dec命令
		- それぞれインクリメント、デクリメントをする
		- dec QWORD PTR [0x602060]だったら、0x602060を始点として格納されている8バイトの値を1減らす
	- mul命令
		- オペランドを1つだけ取り、このオペランドとraxレジスタの値を掛け算する
		- 結果は上半分がrdxレジスタ、下半分がraxレジスタに格納されると書いてあるが、何をもって上半分と下半分なのか分からない
	- div命令
		- オペランドを1つだけ取り、raxレジスタの値をこのオペランドで割り算する
		- 商がraxレジスタ、剰余がrdxレジスタに格納される
		- ```
		  mov rax, 21
		  mvo rdx, 5
		  div rdx
		  ```
			- raxレジスタには4が、rdxレジスタには1が格納される
	- imul命令、idiv命令
		- imul命令とidiv命令は符号付きで乗算、除算を行う
		- iはintegerを意味する
		- imul命令はオペランドを3つまで取ることが出来る
			- 1つの場合はmul命令と同じ挙動をする
			- 2つの場合は第1オペランドと第2オペランドを掛け算し、結果を第1オペランドに格納する
			- 3つの場合は第2オペランドと第3オペランドを掛け算し、結果を第1オペランドに格納する
	- and命令、or命令
		- それぞれ第1オペランドと第2オペランドの論理積/論理和を取って、結果を第1オペランドに格納する
	- xor命令
		- 第1オペランドと第2オペランドの排他的論理和を取って、結果を第1オペランドに格納する
		- 同じレジスタをXORすると、そのレジスタが0になる
			- xor rax, raxなど
			- mov rax, 0よりも機械語にした時のサイズが小さくなる
		- mov eax, eaxだと、下位32ビットのみが0になりそうだが、仕様上raxレジスタ全体が0になる
	- not命令
		- 第1オペランドの否定を取り、結果を第1オペランドに格納する
	- shl命令、shr命令、sal命令、sar命令
		- 論理シフトと算術シフト([参考](https://qiita.com/Upatissa/items/a83dcb92f124c22d0565))
			- 論理シフトは符号なし整数に行われるもので、全体を左にシフト / 右にシフトさせて、空いたビットには0を埋める
				- 左シフトで1がはみ出たらオーバフロー
			- 算術シフトは符号付き整数に行われるもので、符号ビット(=先頭ビット)を除いて、左にシフト / 右にシフトさせて、空いたビットには左シフトの場合0を、右シフトの場合は符号ビットを埋める
				- 左シフトで符号ビットと異なるビットがはみ出たらオーバフロー
				- 0b11101000(=-24)を算術左シフトで2ビットずらすと0b10100000(=-96)
				- 0b11101000(=-24)を算術右シフトで2ビットずらすと0b11111010(=-6)
		- shl命令、shr命令は論理シフト、sal命令、sar命令は算術シフト
		- オペランドを1つ取る時は1ビットだけシフトさせる
		- オペランドを2つ取る時は第1オペランドを第2オペランドの値だけシフトさせる
			- ただし第2オペランドは即値もしくはclレジスタのみ指定出来る
	- cmp命令
		- 第1オペランドと第2オペランドの値が同じならZFを1にし、そうでなければ0にする
		- 代表的なフラグと1になる条件
			- ZF(Zero Flag) : 演算結果が0
			- SF(Signed Flag) : 演算結果が負数
			- CF(Carry Flag) : 符号なし演算で桁溢れが発生
			- OF(Overflow Flag) : 符号付き演算で桁溢れが発生
		- cmp A, Bは内部ではA - Bを計算している(sub A, Bで良くない？)
	- test命令
		- 第1オペランドと第2オペランドの論理積が0ならZFを1にし、そうでなければ0にする
		- if (var) { ... } else { ... } のような条件分岐によく使われる
			- オペランドを2つともvarにする
			- cmp命令を使っても良いが、test命令の方が機械語のサイズが小さくて済む
	- jmp命令
		- ジャンプ先のアドレスを表すオペランドを1つ取る
			- プログラムを逆アセンブルすると、一般的にアドレスになっているが、アセンブリコードを書くときはラベルを指定出来る
		- フラグレジスタの値に関係なくジャンプする
	- jz命令、je命令
		- ZFが1の時にジャンプする
		- それぞれJump if Zero, Jump if Equalの略
	- jnz命令、jne命令
		- ZFが0の時にジャンプする
		- それぞれJump if Not Zero, Jump if Not Equalの略
	- ja命令、jae命令
		- jaはCF=0 かつ ZF=0のとき、jaeはCF=0のときにジャンプする
		- それぞれJump if Above, Jump if Above or Equalの略