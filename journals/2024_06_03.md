# malloc / free の勉強
	- https://www.youtube.com/watch?v=0-vWT-t0UHg
	- https://www.slideshare.net/slideshow/glibc-malloc/8555290
	- p4 ~ p13
		- 古典的mallocについて説明されている
		- 参考
			- https://www.ei.fukui-nct.ac.jp/2019/01/15/malloc-freelist-2/
			- https://qiita.com/hiyoko_40/items/215426043ccc8dcc9510
			- https://apribase.net/2008/06/10/malloc/ (実装例あり)
		- 空き領域はfree_listという構造で管理されている
		- free_listの各要素は、次の要素へのポインタと、空き領域のサイズを持つ
			- スライドでは、最後の要素が持つポインタは、先頭の要素を指しているが、参考リンクの3個目によるとNULLらしい
		- mallocを呼び出すと、free_listを順に辿っていき、必要な領域のサイズ(mallocの引数で渡す)以上の空き領域を見つけたら、その空き領域を使う
			- 最初に見つけたものを使用する(first hit)
			- 必要な領域のサイズよりも、空き領域のサイズの方が大きければ、空き領域の後半に割り当てる
				- p8では前半に割り当てているけど
			- 正確には、mallocの引数で指定したサイズよりも管理領域分だけ多く割り当てる
		- freeを呼び出すと、領域が開放される
			- 隣接する領域が空き領域なら併合する
				- これをしないと、mallocとfreeを繰り返すことで、小さい空き領域ばかりになり、大きい領域を割り当てられなくなる
			- 併合方法はp13に書いてある(謎の記号は<)
		- list_headからfree_listを辿っていく
			- mallocやfreeでlist_headが変更される
	- p14 ~ p24
		- 割り当て可能な空き領域が見つからない時は、brkシステムコールを使って、ヒープ領域を伸ばす
		- p22は分からなかった
	- p25 ~ p28
		- 古典的mallocのメリット
			- 実装量が少ない
			- フラグメンテーションが進まない限り、mallocはO(1)
				- フラグメンテーションとは、小さい空き領域ばかりになり、全体の空き領域は十分でも、大きい領域を割り当てられなくなること
				- first hitだからといって、O(1)とする理由が分からない
		- 古典的mallocのデメリット
			- 小さいmallocが多発すると、フラグメンテーションがすぐ進むことがデメリット
			- freeがO(n)
				- nってなんだ free_listの長さ?
			- フラグメンテーションが進むと、mallocでfree_listを一周し、大量のアクセスが行われるため、CPUのキャッシュを活かせず遅くなる