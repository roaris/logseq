# 暗号技術入門
- ## 第14章 SSL/TLS
- ### SSL/TLSとは
	- TLSはSSLの新しいバージョン
		- 2014年、SSL 3.0の仕様にPOODLE攻撃が可能な脆弱性が見つかった
		- TLSはSSL 3.0を元にして作られた
	- クライアントからサーバに情報を送る時に満たすべき条件は以下の3つ
		- 盗聴されることなく情報を送りたい(機密性)
			- 対称暗号を用いる
				- 鍵は擬似乱数生成器で作る
				- 鍵を安全に共有するために公開鍵暗号やDiffie-Hellman鍵交換を使う
		- 改竄されることなく情報を送りたい(正真性)
			- メッセージ認証コードを用いる
		- 通信先のサーバが正当なものであるかを確かめたい(認証)
			- 通信先のサーバの公開鍵の証明書を用いる
	- SSL/TLSは上記の暗号通信の枠組みを提供するもの
		- 使用する対称暗号、公開鍵暗号、一方向ハッシュ関数などの方式を交換することが出来る
		- しかし、クライアントとサーバは同じ暗号技術を使わなければ通信出来ないため、自由に選択出来るわけではない
		- そのためSSL/TLSでは、暗号技術の「お勧めセット」が規定されていて、これを暗号スイートと呼ぶ
	- SSL/TLSの上にはHTTPだけではなく、SMTPやPOP3などのプロトコルも乗せることが出来る
- ### TLSの中身
	- 暗号化の処理をするTLSレコードプロトコルと、暗号化以外の処理を行うTLSハンドシェイクプロトコルに分かれる
	- TLSレコードプロトコル
		- メッセージを複数のフラグメントに分割し、各フラグメントを圧縮する
		- 圧縮したフラグメントにメッセージ認証コードのMAC値を付与する
			- 再生攻撃を防ぐために、フラグメントにつけられた番号をMAC値の計算に含める
		- 圧縮したフラグメントとメッセージ認証コードを合わせて、対称暗号とCBCモードで暗号化する
			- 初期化ベクトルはマスターシークレットから作成する
		- データのタイプ、バージョン番号、圧縮した長さからなるヘッダを付加して、送信する
			- データのタイプとは、TLSレコードプロトコルの上に乗っている4つのサブプロトコル(ハンドシェイクプロトコル、暗号仕様変更プロトコル、警告プロトコル、アプリケーションデータプロトコル)のうち、どれであるかを表したもの
		- 圧縮に使うアルゴリズム、一方向ハッシュ関数アルゴリズム、メッセージ認証コードで使う共通鍵、対称暗号のアルゴリズム、対称暗号の共通鍵をクライアントとサーバで共有する必要があり、これはハンドシェイクプロトコルの役割
	- TLSハンドシェイクプロトコル
		- ハンドシェイクプロトコル、暗号仕様変更プロトコル、警告プロトコル、アプリケーションデータプロトコルに分かれている
		- ハンドシェイクプロトコル
			- 1. ClientHello (クライアント → サーバ)
				- 使用出来るバージョン番号、使用出来る暗号スイートの一覧、使用出来る圧縮方法の一覧を送る
				- クライアントランダムという、クライアントが生成した予測不可能性を持つ乱数も送る
			- 2. ServerHello (クライアント ← サーバ)
				- ClientHelloで送ってきた情報を元にして、使用出来るバージョン番号、使用出来る暗号スイートの一覧、使用出来る圧縮方法をサーバが決めて送る
				- サーバランダムという、サーバが生成した予測不可能性を持つ乱数も送る(クライアントランダムと無関係でなければいけない)
			- 3. Certificate (クライアント ← サーバ)
				- サーバの証明書が送られる、クライアントはこれを検証する
			- 4. ServerKeyExchange (クライアント ← サーバ)
				- 暗号化の鍵について、Certificateだけでは情報が足りない時に必要な情報を送る
					- Diffie-Hellman鍵交換を用いる場合の、サーバ側の公開値など
			- 5. CertificateRequest (クライアント ← サーバ)
				- クライアント認証のために、サーバがクライアントの証明書を要求する(クライアント認証を用いない場合は送信されない)
			- 6. ServerHelloDone (クライアント ← サーバ)
				- ServerHelloから始まる一連のメッセージの終わりを示す
			- 7. Certificate (クライアント → サーバ)
				- CertificateRequestが送られてきた場合、クライアントは自分の証明書を送る、サーバはこれを検証する
			- 8. ClientKeyExchange (クライアント → サーバ)
				- RSAを用いる場合、サーバの公開鍵で暗号化されたプレマスターシークレットが送信される
					- プレマスターシークレットとはクライアントが作った乱数で、マスターシークレットを作るための種の役割をするもの
					- プレマスターシークレットを使って、サーバとクライアントは共通のマスターシークレットを計算し、このマスターシークレットを元に対称暗号の鍵、メッセージ認証コードの鍵、対称暗号のCBCモードで用いる初期化ベクトルを作り出す
				- Diffie-Hellman鍵交換を用いる場合、公開値が送られる
			- 9. CertificateVerify (クライアント → サーバ)
				- クライアントがクライアント証明書の本人であることを示すためのメッセージ
					- それは認証局の役割では？クライアント証明書とサーバ証明書は何か違う？
			- 10. ChangeCipherSpec (クライアント → サーバ)
				- クライアントが暗号を切り替えるというメッセージ(暗号仕様変更プロトコルのメッセージ)
			- 11. Finished (クライアント → サーバ)
				- Finishedメッセージを送って、ハンドシェイクプロトコルが終了したことを伝える
				- Finishedメッセージは切り替えた暗号スイートで暗号化されて送られる(実際に暗号化をするのはTLSレコードプロトコル)
					- サーバはこれを復号化して、正しいFinishedメッセージが得られることで、クライアント側の暗号スイートが正しく切り替わったことを確認する
			- 12. ChangeCipherSpec (クライアント ← サーバ)
				- サーバが暗号を切り替えるというメッセージ
			- 13. Finished (クライアント ← サーバ)
				- クライアントと同様、サーバも切り替えた暗号スイートでFinishedメッセージを暗号化して送る
			- 14. アプリケーションデータプロトコルへ移行
		- 暗号仕様変更プロトコル
			- 暗号を切り替える合図を行うためのもの
			- 一旦暗号通信を始めた後でも再度ハンドシェイクをして、暗号スイートを変更することが可能
			- 最初の時点では「暗号化なし」という暗号スイートで通信していて、通信は暗号化されていない
		- 警告プロトコル
			- 何らかのエラー(メッセージ認証コードが間違っていたり、圧縮データが上手く伸張出来なかったなど)が発生したことを通信相手に伝えるためのもの
		- アプリケーションデータプロトコル
			- アプリケーションのデータを通信相手とやりとりするプロトコル
			- TLSの上にHTTPが乗っている場合は、HTTPのリクエストとレスポンスは、TLSのアプリケーションデータプロトコルとTLSレコードプロトコルを通って、やり取りされる
	- マスターシークレットの計算
		- プレマスターシークレットとクライアントランダムとサーバランダムを元にして計算される
		- クライアントランダムとサーバランダムはソルトの役割を果たす(？)
- # C10K問題
	- [C10K問題とNode.js - Qiita](https://qiita.com/katu_/items/01c9c35d17a541014d32)
	- C10Kはクライアント1万台という意味
	- リクエストが来るたびにスレッドが立ち上がるため、クライアントが1万台ぐらいになると、リソースが不足して、サーバがパンクする
	- Goのnet/httpでは新しいリクエストが来た時にgoroutine(goroutineは軽量スレッド)で処理するようになっていて、C10K問題は発生しにくい
		- https://github.com/golang/go/blob/5d5305026ec51ff3aaa6e7a7c18a815a3ac787c7/src/net/http/server.go#L3086
		- https://christina04.hatenablog.com/entry/why-goroutine-is-good
- # Misc
	- [xargsコマンド](https://qiita.com/P-man_Brown/items/c3f2634b7b5e08306c8f)
		- 前のコマンドの実行結果を次のコマンドに引数に渡して実行できる