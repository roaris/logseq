# はじめて学ぶバイナリ解析
- レジスタ
	- 汎用レジスタ
		- 様々な用途に用いられるレジスタ
		- 暗黙的に使い方が決められているものもある
			- EAX(アキュムレータレジスタ) : 返り値(計算結果)など
			- EBX(ベースレジスタ) : アドレスのベース値
			- ECX(カウンタレジスタ) : ループ回数のカウントなど
			- EDX(データレジスタ) : 演算に用いるデータ
	- 特殊レジスタ
		- 特有の用途を持つレジスタ
		- ESP(スタックポインタ) : 実行中の関数のスタックのトップ
		- EBP(スタックベースポインタ) : 実行中の関数のスタックのボトム
		- EIP(インストラクションポインタ) : 次に実行する命令のアドレス
			- CPUはEIPレジスタが指すアドレスにアクセスして、次に実行する命令を知ることが出来る
	- フラグレジスタ
		- 命令や演算の実行結果として生じた状態を保存するレジスタ
		- EFLAGSという32ビットの1つのレジスタにまとめられている([参考](https://www.wdic.org/w/SCI/EFLAGS))
		- 状態に応じて該当ビットが1になる
		- 使用頻度の高いのはゼロフラグ(ZF)で、これは事前の演算結果が0であれば1になり、そうでない時は0になる
	- 先頭のEは32ビット仕様のレジスタであることを表している
	- 64ビット仕様の場合は、RAX, RBX, ...となる
- gdb-pedaの表示の見方
	- 逆アセンブル結果(---code---)
		- 表示されているアドレスは、各行の命令がプログラム部のどこに格納されているかを表す
		- <main+3>などは、関数の開始部分を0とした時の相対的なアドレスを示す
		- =>は次に実行される命令を表す(=>が指すアドレスとEIPレジスタの値は同じ)
	- レジスタ(---registers---)
		- EFLAGS
			- 例 `EFLAGS: 0x246 (carry PARITY adjust ZERO sign trap INTERRUPT direction overflow)`
			- 緑色(小文字)のフラグは0、赤色(大文字)のフラグは1
			- PARITYは2ビット目、ZEROは6ビット目、INTERRUPTは9ビット目、1ビット目は必ず1なので、0000,0000,0000,0000,0000,0010,0100,0110となり、16進数にすると0x246
		- i registerでもレジスタを確認することが出来る
- gdb-pedaによるレジスタの書き換え
	- set $eax = 0 や set $esp = 0x12345678 など
	- ゼロフラグを1にするならset $eflags |= 1<<6, 0にするならset $eflags  &= ~(1<<6)
- 条件分岐
	- cmpなどの命令でフラグレジスタを更新 → jeなどのジャンプ命令で分岐する
	- jeはゼロフラグが1なら指定したアドレスにジャンプする