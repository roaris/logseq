# malloc / free の勉強(続き)
	- https://www.youtube.com/watch?v=0-vWT-t0UHg
	- https://www.slideshare.net/slideshow/glibc-malloc/8555290
	- p41 ~ p45
		- ヘッダのサイズは減らせたので、次にmallocがO(n)である問題を解決する
		- 全ての空き領域を1つのfree_listで管理するのをやめる
		- サイズ16の空き領域用のfree_list、サイズ24の空き領域用のfree_list、...という風にする
			- glibc mallocではメモリアドレスが8の倍数なので、空き領域のサイズも8の倍数
			- 例えば、malloc(20)としたら、要求された20バイトを8の倍数に切り上げると24バイトになるので、サイズ24の空き領域用のfree_list中の空き領域を割り当てる
				- best_fitかつO(1)が実現出来る
			- p43
				- 図にサイズ8がないのはなぜ?
				- 図にサイズ512がないのはなぜ?(コードでは、サイズ512も含まれているが)
		- 各サイズの空き領域用のfree_listをbinと呼ぶ
		- 512バイトまでは8バイトおきにbinを作る
			- small binという
		- 512バイトを超えるmallocは滅多にないので、512バイトを超えてからは8バイトおきにbinを作るのは効率的ではない
			- バイト数が大きくなるにつれて、間隔を広げていく
			- large binという
	- p46
		- 一番ラストのbinが一杯つながるとは?
			- binに含まれる空き領域の数が多いということ?
			- 多いと何が問題になる?
			- 数十Mのmallocが原因となるのも理解出来ない
	- p47 ~ p49
		- 大きい領域(デフォルトで128KB以上)は、free_listからではなく、mmapで領域を取得することを考える
		- mmapはファイルをメモリ領域にマッピングする関数([参考](https://mkguytone.github.io/allocator-navigatable/ch73.html))
		- ファイルに/dev/zeroを指定すると、メモリ確保用の関数として使える
			- /dev/zeroはヌルバイトがどこまでも続くファイル([参考](https://qiita.com/umeee/items/4e6b9ef349a0ed291644))
		- sizeの下から2ビット目をmmapで取得したかのフラグにする
		- このフラグが1なら、free時にfree_listにつなぐのではなく、munmapでマッピングを解除する
	- p50
		- スライドの矢印が変になっているので、動画の方を見ると良い
		- mmapで確保した領域はfreeしてもfree_listで管理しない(munmapでOSに返却するだけ)
		- ソースコードを簡単にするために、mmapで確保した領域にもヘッダがつく(使わないけど)
	- p51 ~ 52
		- ここまでの工夫でどうなったか
			- freeがO(1)
				- ヘッダにprev_size, sizeを持たせたため
			- フラグメンテーションが起こりにくくなった & mallocがO(1)
				- free_listをbin毎に分け、要求されたバイト数を8の倍数に切り上げたサイズのbinから空き領域を割り当てれば良い
		- p46を理解してないから、128KB以上の領域についてmmap/munmapを使うことによる利点は理解してない
	- p53 ~ p55
		- ここまで工夫しても古典的mallocに負けることがある
		- キャッシュのヒット率が古典的mallocの方が良いことが理由
		- mallocで確保したメモリへのアクセスする可能性が高いのは、malloc直後とfree直前
		- freeされたばかりのメモリはキャッシュに載っている可能性が高い
			- その周辺もキャッシュに載っている可能性が高い(参照局所性)
		- 次にmallocする時に、freeされたところとその周辺を優先して使うようにすれば、malloc直後のアクセスでキャッシュミスが減る
			- メモリに書き込むのではなく、キャッシュに書き込みさえすれば良いということである
		- 古典的mallocでは、freeされたところにlist_headを動かすようになっているので、キャッシュを活かせるようになっている
		- free_listをbin毎に分ける方法では、best_fitを優先していて、キャッシュを活かせるような仕組みにはなっていない
	- p56 ~ p57
		- freeが呼ばれた時に隣接する空き領域と併合するのを遅らせる
			- 空き領域Aとそれに続く空き領域Bがあって、空き領域Bがfreeされた直後だとして、AとBを併合すると、mallocした時にAから使われることになり、Bのキャッシュを活かせなくなる
		- freeされた領域を時系列順で持っておいて(ソースコード上でunsorted_chunkと呼ばれている)、最近freeされた領域から使っていくことで、キャッシュを有効活用する
			- サイズ毎のbinも併用するだよね?どうやって併用するのか分からないけど
			- mallocの効率が落ちるということはない?
	- p58 ~ p59
		- 一般的なアプリケーションの傾向
			- 起動時はmallocがたくさん呼ばれる(バースト状態)
			- その後mallocとfreeがほぼ交互に呼ばれ(定常状態)
			- 画面遷移のような契機で、freeがたくさん呼ばれて、次にmallocがたくさん呼ばれる(バースト状態)
			- また定常状態になる
		- unsorted_chunkは、定常状態で効果があり、freeがたくさん呼ばれて、次にmallocがたくさん呼ばれるバースト状態では逆効果
			- 定常状態では、同じサイズの構造体をmalloc, freeすることが多く、unsorted_chunkから使用可能な空き領域がすぐに見つかる & キャッシュも有効活用出来る
			- freeがたくさん呼ばれて、次にmallocがたくさん呼ばれるバースト状態では、freeがたくさん呼ばれることで、様々なサイズの空き領域がunsorted_chunk含まれるようになり、mallocが遅くなる
				- しかし、元々キャッシュを有効活用出来なくて遅いので、さらに遅くなっても良いと、割り切られている
		- p59 遅延併合って書いてあるけど、口頭で説明されているのは、unsorted_chunkなんだよな