- # SQLインジェクションの対策
- [参考](https://www.ipa.go.jp/security/vuln/websecurity/ug65p900000196e2-att/000017320.pdf)
- SQLの呼び出し方には、文字列連結による組み立てとプレースホルダ(静的、動的)による組み立ての2つがある
- ## 文字列連結による組み立て
	- SQLインジェクションを防ぐために、エスケープ処理が必要となる
	- 例えば、シングルクォートの前にはシングルクォートを追加することでエスケープさせることが出来る
		- ```
		  SELECT * FROM employee WHERE name = 'O'Reilly'; ← エラーになる
		  SELECT * FROM employee WHERE name = 'O''Reilly'; ← OK
		  ```
	- エスケープが必要な文字は、データベースエンジンの種類や設定によって変わるため、開発者がエスケープ処理を自前で実装するのは困難
- ## プレースホルダによる組み立て
- パラメータ部分を?などの記号で表しておいて、後から値を機械的な処理で割り当てる方法(値を割り当てることを「バインドする」という
- ### 静的プレースホルダ
	- プレースホルダのままのSQL文をデータベースに送信して、データベースエンジン側で構文解析を行う
	- SQLを実行するタイミングで、パラメータに入れる値をデータベースエンジンに送信し、データベースエンジンがバインド処理をする
	- バインド処理をする時、既に構文解析が終了しているため、パラメータの値がリテラルの外にはみ出るということはない(シングルクォートを含むような値であっても、それはただのシングルクォートとして扱われる)
- ### 動的プレースホルダ
	- アプリケーション側のライブラリがデータベースと連動しながら、エスケープ処理を行って、SQLを組み立てる
	- 静的プレースホルダーと異なり、完成されたSQLがデータベースに渡る
	- 開発者が自前で実装したエスケープ処理を用いるよりかは良いが、アプリケーション側のライブラリに脆弱性があるかもしれない
- # Chromeの2分間ルール
	- Chrome84から、CookieのSameSite属性が指定されていない場合は、自動でLaxが指定されるようになった(それまでは自動でNoneが指定されていた) [参考](https://help.salesforce.com/s/articleView?id=000381201&type=1)
		- DevToolsから確認してもLaxと書いていないが、Laxになっている
	- CookieのSameSite属性 [参考](https://qiita.com/KWS_0901/items/695bd1ecc17a8c2e6d69)
		- Strict : 別ドメインへのリクエスト全てでCookieを送ることが出来ない
		- Lax : 別ドメインへのGETリクエストのみCookieを送ることが出来る
		- None : 制限なくCookieを送ることが出来る(ただしSecure属性が必要)
	- SameSite属性がLaxである時、別ドメインにPOSTリクエストを送信する時、Cookieは送ることは出来ないのだが、Cookieが生成されてから2分間だけは送れるという仕様がある [参考](https://blog.tokumaru.org/2022/01/impact-conditions-for-no-CSRF-protection-sites.html)
	- ログイン機能で別ドメインにPOSTリクエストでデータを送信するようなサービスへの影響を緩和するために、このような仕様が存在する [参考](https://www.ecbeing.net/contents/detail/235)